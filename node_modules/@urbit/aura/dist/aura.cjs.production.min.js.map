{"version":3,"file":"aura.cjs.production.min.js","sources":["../src/d.ts","../src/hoon/muk.ts","../src/hoon/ob.ts","../src/p.ts","../src/q.ts","../src/r.ts","../src/parse.ts","../src/render.ts","../src/index.ts"],"sourcesContent":["/**\n * Given a string formatted as a `@da`, returns a bigint representing the urbit date.\n *\n * @param   {string}  x  The formatted `@da`\n * @return  {bigint}     The urbit date as bigint\n */\nexport function parseDa(x: string): bigint {\n  let pos = true;\n  let [date, time, ms] = x.split('..');\n  time = time || '0.0.0';\n  ms = ms || '0000';\n  let [yer, month, day] = date.slice(1).split('.');\n  if (yer.at(-1) === '-') {\n    yer = yer.slice(0, -1);\n    pos = false;\n  }\n  const [hour, minute, sec] = time.split('.');\n  const millis = ms.split('.').map((m) => BigInt('0x' + m));\n\n  return year({\n    pos: pos,\n    year: BigInt(yer),\n    month: BigInt(month),\n    time: {\n      day: BigInt(day),\n      hour: BigInt(hour),\n      minute: BigInt(minute),\n      second: BigInt(sec),\n      ms: millis,\n    },\n  });\n}\n\nexport function parseDr(x: string): bigint {\n  const rop: Tarp = { day: 0n, hour: 0n, minute: 0n, second: 0n, ms: [] };\n  x = x.slice(1);  //  strip ~\n  let [time, ms] = x.split('..');\n  ms = ms || '0000';\n  rop.ms = ms.split('.').map((m) => BigInt('0x' + m));\n  time.split('.').forEach((a) => {\n    switch (a[0]) {\n      case 'd': rop.day    += BigInt(a.slice(1)); break;\n      case 'h': rop.hour   += BigInt(a.slice(1)); break;\n      case 'm': rop.minute += BigInt(a.slice(1)); break;\n      case 's': rop.second += BigInt(a.slice(1)); break;\n      default: throw new Error('bad dr: ' + x);\n    }\n  });\n  ms = ms || '0000';\n  return yule(rop);\n}\n\n/**\n * Given a bigint representing an urbit date, returns a string formatted as a proper `@da`.\n *\n * @param   {bigint}  x  The urbit date as bigint\n * @return  {string}     The formatted `@da`\n */\nexport function renderDa(x: bigint): string {\n  const { pos, year, month, time } = yore(x);\n  let out = `~${year}${pos ? '' : '-'}.${month}.${time.day}`;\n  if (time.hour !== 0n || time.minute !== 0n || time.second !== 0n || time.ms.length !== 0) {\n    out = out + `..${time.hour.toString().padStart(2, '0')}.${time.minute.toString().padStart(2, '0')}.${time.second.toString().padStart(2, '0')}`\n    if (time.ms.length !== 0) {\n      out = out + `..${time.ms.map((x) => x.toString(16).padStart(4, '0')).join('.')}`;\n    }\n  }\n  return out;\n}\n\nexport function renderDr(x: bigint): string {\n  if (x === 0n) return '~s0';\n  const { day, hour, minute, second, ms } = yell(x);\n  let out: string[] = [];\n  if (day    !== 0n) out.push('d' + day.toString());\n  if (hour   !== 0n) out.push('h' + hour.toString());\n  if (minute !== 0n) out.push('m' + minute.toString());\n  if (second !== 0n) out.push('s' + second.toString());\n  if (ms.length !== 0) {\n    if (out.length === 0) out.push('s0');\n    out.push('.' + ms.map((x) => x.toString(16).padStart(4, '0')).join('.'));\n  }\n  return '~' + out.join('.');\n}\n\n/**\n * Given a bigint representing an urbit date, returns a unix timestamp.\n *\n * @param   {bigint}  da  The urbit date\n * @return  {number}      The unix timestamp\n */\nexport function toUnix(da: bigint): number {\n  // ported from +time:enjs:format in hoon.hoon\n  const offset = DA_SECOND / 2000n;\n  const epochAdjusted = offset + (da - DA_UNIX_EPOCH);\n\n  return Math.round(\n    Number(epochAdjusted * 1000n / DA_SECOND)\n  );\n}\n\n/**\n * Given a unix timestamp, returns a bigint representing an urbit date\n *\n * @param   {number}  unix  The unix timestamp\n * @return  {bigint}        The urbit date\n */\nexport function fromUnix(unix: number): bigint {\n  const timeSinceEpoch = BigInt(unix) * DA_SECOND / 1000n;\n  return DA_UNIX_EPOCH + timeSinceEpoch;\n}\n\n/**\n * Given a number of seconds, return a bigint representing its `@dr`\n */\nexport function fromSeconds(seconds: bigint): bigint {\n  return yule({ day: 0n, hour: 0n, minute: 0n, second: seconds, ms: [] });\n}\n\n/**\n * Convert a `@dr` to the amount of seconds it represents, dropping sub-\n * second precision\n */\nexport function toSeconds(dr: bigint): bigint {\n  const { day, hour, minute, second } = yell(dr);\n  return (((((day * 24n) + hour) * 60n) + minute) * 60n) + second;\n}\n\n//\n//  internals\n//\n\ninterface Dat {\n  pos: boolean;\n  year: bigint;\n  month: bigint;\n  time: Tarp;\n}\n\ninterface Tarp {\n  day: bigint;\n  hour: bigint;\n  minute: bigint;\n  second: bigint;\n  ms: bigint[];\n}\n\nconst DA_UNIX_EPOCH = BigInt('170141184475152167957503069145530368000'); // `@ud` ~1970.1.1\n\nconst DA_SECOND = BigInt('18446744073709551616'); // `@ud` ~s1\n\nconst EPOCH = BigInt('292277024400');\n\nfunction isLeapYear(year: bigint) {\n  return (year % 4n) === 0n\n      && (year % 100n) !== 0n\n      || (year % 400n) === 0n;\n}\nconst MOH_YO = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst MOY_YO = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst DAY_YO = 86400n;\nconst HOR_YO = 3600n;\nconst MIT_YO = 60n;\nconst ERA_YO = 146097n;\nconst CET_YO = 36524n;\n\nfunction year(det: Dat) {\n  const yer = det.pos\n    ? EPOCH + (BigInt(det.year))\n    : EPOCH - (BigInt(det.year) - 1n);\n  const day = (() => {\n    let cah = isLeapYear(yer) ? MOY_YO : MOH_YO;\n    let d = det.time.day - 1n;\n    let m = det.month - 1n;\n    while (m !== 0n) {\n      const [first, ...rest] = cah;\n      d = d + BigInt(first);\n      m = m - 1n;\n      cah = rest;\n    }\n    let loop: boolean = true;\n    let y = yer;\n    while (loop == true) {\n      if ((y % 4n) !== 0n) {\n        y = y - 1n;\n        d = d + (isLeapYear(y) ? 366n : 365n);\n      } else if ((y % 100n) !== 0n) {\n        y = y - 4n;\n        d = d + (isLeapYear(y) ? 1461n : 1460n);\n      } else if ((y % 400n) !== 0n) {\n        y = y - 100n;\n        d = d + (isLeapYear(y) ? 36525n : 36524n);\n      } else {\n        let eras = y / 400n;\n        d = d + (eras * (4n * 36524n + 1n));\n        loop = false;\n      }\n    }\n    return d;\n  })();\n\n  det.time.day = day;\n  return yule(det.time);\n}\n\nfunction yule(rip: Tarp): bigint {\n  let sec = rip.second\n    + (DAY_YO * rip.day)\n    + (HOR_YO * rip.hour)\n    + (MIT_YO * rip.minute);\n\n  let ms = rip.ms;\n  let fac = 0n;\n  let muc = 3n;\n  while (ms.length !== 0) {\n    const [first, ...rest] = ms;\n    fac = fac + (first << (16n * muc));\n    ms = rest;\n    muc -= 1n;\n  }\n\n  return fac | (sec << 64n);\n}\n\nfunction yell(x: bigint): Tarp {\n  let sec = x >> 64n;\n  const milliMask = BigInt('0xffffffffffffffff');\n  const millis = milliMask & x;\n  const ms = millis\n    .toString(16).padStart(16, '0')\n    .match(/.{4}/g)!\n    .map((x) => BigInt('0x'+x));\n  while (ms.at(-1) === 0n) {\n    ms.pop();\n  }\n  let day = sec / DAY_YO;\n  sec = sec % DAY_YO;\n  let hor = sec / HOR_YO;\n  sec = sec % HOR_YO;\n  let mit = sec / MIT_YO;\n  sec = sec % MIT_YO;\n\n  return {\n    ms,\n    day,\n    minute: mit,\n    hour: hor,\n    second: sec,\n  };\n}\n\nfunction yall(day: bigint): [bigint, bigint, bigint] {\n  let era = 0n;\n  let cet = 0n;\n  let lep = false;\n  era = day / ERA_YO;\n  day = day % ERA_YO;\n  if (day < (CET_YO + 1n)) {\n    lep = true;\n  } else {\n    lep = false;\n    cet = 1n;\n    day = day - (CET_YO + 1n);\n    cet = cet + (day / CET_YO);\n    day = day % CET_YO;\n  }\n  let yer = (era * 400n) + (cet * 100n);\n  let loop = true;\n  while (loop == true) {\n    let dis = lep ? 366n : 365n;\n    if (!(day < dis)) {\n      yer = yer + 1n;\n      day = day - dis;\n      lep = (yer % 4n) === 0n;\n    } else {\n      loop = false;\n      let inner = true;\n      let mot = 0n;\n      while (inner) {\n        let cah = lep ? MOY_YO : MOH_YO;\n        let zis = BigInt(cah[Number(mot)]);\n        if (day < zis) {\n          return [yer, mot + 1n, day + 1n];\n        }\n        mot = mot + 1n;\n        day = day - zis;\n      }\n    }\n  }\n  return [0n, 0n, 0n];\n}\n\nfunction yore(x: bigint): Dat {\n  const time = yell(x);\n  const [y, month, d] = yall(time.day);\n  time.day = d;\n  const pos = y > EPOCH;\n  const year = pos ? y - EPOCH : EPOCH + 1n - y;\n\n  return {\n    pos,\n    year,\n    month,\n    time,\n  };\n}\n","// ++  muk\n//\n// See arvo/sys/hoon.hoon.\n\n/**\n * Standard murmur3.\n *\n * @param  {Number}       syd\n * @param  {Number}       len\n * @param  {bigint}       key\n * @return {bigint}\n */\nexport const muk = (syd: number, key: bigint): bigint => {\n  const lo = Number(key & 0xffn);\n  const hi = Number((key & 0xff00n) / 256n);\n  const kee = String.fromCharCode(lo) + String.fromCharCode(hi);\n  return BigInt(murmurhash3_32_gc(kee, syd));\n};\n\n// see: https://github.com/garycourt/murmurhash-js\n//\n// Copyright (c) 2011 Gary Court\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n/**\n * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n *\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n *\n * @param {string} key ASCII only\n * @param {number} seed Positive integer only\n * @return {number} 32-bit positive integer hash\n **/\nconst murmurhash3_32_gc = (key: string, seed: number) => {\n  let remainder, bytes, h1, h1b, c1, c2, k1, i; // c1b, c2b unused\n\n  remainder = key.length & 3; // key.length % 4\n  bytes = key.length - remainder;\n  h1 = seed;\n  c1 = 0xcc9e2d51;\n  c2 = 0x1b873593;\n  i = 0;\n\n  while (i < bytes) {\n    k1 =\n      (key.charCodeAt(i) & 0xff) |\n      ((key.charCodeAt(++i) & 0xff) << 8) |\n      ((key.charCodeAt(++i) & 0xff) << 16) |\n      ((key.charCodeAt(++i) & 0xff) << 24);\n    ++i;\n\n    k1 =\n      ((k1 & 0xffff) * c1 + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n    k1 = (k1 << 15) | (k1 >>> 17);\n    k1 =\n      ((k1 & 0xffff) * c2 + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n\n    h1 ^= k1;\n    h1 = (h1 << 13) | (h1 >>> 19);\n    h1b =\n      ((h1 & 0xffff) * 5 + ((((h1 >>> 16) * 5) & 0xffff) << 16)) & 0xffffffff;\n    h1 = (h1b & 0xffff) + 0x6b64 + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16);\n  }\n\n  k1 = 0;\n\n  switch (remainder) {\n    case 3:\n      k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n    case 2:\n      k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n    case 1:\n      k1 ^= key.charCodeAt(i) & 0xff;\n\n      k1 =\n        ((k1 & 0xffff) * c1 + ((((k1 >>> 16) * c1) & 0xffff) << 16)) &\n        0xffffffff;\n      k1 = (k1 << 15) | (k1 >>> 17);\n      k1 =\n        ((k1 & 0xffff) * c2 + ((((k1 >>> 16) * c2) & 0xffff) << 16)) &\n        0xffffffff;\n      h1 ^= k1;\n  }\n\n  h1 ^= key.length;\n\n  h1 ^= h1 >>> 16;\n  h1 =\n    ((h1 & 0xffff) * 0x85ebca6b +\n      ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) &\n    0xffffffff;\n  h1 ^= h1 >>> 13;\n  h1 =\n    ((h1 & 0xffff) * 0xc2b2ae35 +\n      ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16)) &\n    0xffffffff;\n  h1 ^= h1 >>> 16;\n\n  return h1 >>> 0;\n};\n","import { muk } from './muk';\n\n// ++  ob\n//\n// See arvo/sys/hoon.hoon.\n\n// a PRF for j in { 0, .., 3 }\nconst F = (j: number, arg: bigint): bigint => {\n  const raku = [0xb76d5eed, 0xee281300, 0x85bcae01, 0x4b387af7];\n\n  return muk(raku[j], arg);\n};\n\n/**\n * Conceal structure v3.\n *\n * @param {String, Number, bigint} pyn\n * @return  {bigint}\n */\nconst fein = (arg: bigint): bigint => {\n  const loop = (pyn: bigint): bigint => {\n    const lo = pyn & 0xffffffffn;\n    const hi = pyn & 0xffffffff00000000n;\n\n    return (pyn >= 0x10000n) && (pyn <= 0xffffffffn)\n      ? (0x10000n + feis(pyn - 0x10000n))\n      : (pyn >= 0x100000000n) && (pyn <= 0xffffffffffffffffn)\n      ? (hi | loop(lo))\n      : pyn;\n  };\n\n  return loop(arg);\n};\n\n/**\n * Restore structure v3.\n *\n * @param  {String, Number, bigint}  cry\n * @return  {bigint}\n */\nconst fynd = (arg: bigint): bigint => {\n  const loop = (cry: bigint): bigint => {\n    const lo = cry & 0xffffffffn;\n    const hi = cry & 0xffffffff00000000n;\n\n    return (cry >= 0x10000n) && (cry <= 0xffffffffn)\n      ? (0x10000n + tail(cry - 0x10000n))\n      : (cry >= 0x100000000n) && (cry <= 0xffffffffffffffffn)\n      ? (hi | loop(lo))\n      : cry;\n  };\n\n  return loop(BigInt(arg));\n};\n\n/**\n * Generalised Feistel cipher.\n *\n * See: Black and Rogaway (2002), \"Ciphers with arbitrary finite domains.\"\n *\n * Note that this has been adjusted from the reference paper in order to\n * support some legacy behaviour.\n *\n * @param  {String, Number, bigint}\n * @return  {BN}\n */\nconst feis = (arg: bigint) =>\n  Fe(4, 65535n, 65536n, 0xffffffffn, F, arg);\n\nconst Fe = (\n  r: number,\n  a: bigint,\n  b: bigint,\n  k: bigint,\n  f: typeof F,\n  m: bigint\n) => {\n  const c = fe(r, a, b, f, m);\n  return (c < k) ? c : fe(r, a, b, f, c);\n};\n\nconst fe = (\n  r: number,\n  a: bigint,\n  b: bigint,\n  f: typeof F,\n  m: bigint\n) => {\n  const loop = (j: number, ell: bigint, arr: bigint): bigint => {\n    if (j > r) {\n      return r % 2 !== 0\n        ? (a * arr) + ell\n        : arr === a\n        ? (a * arr) + ell\n        : (a * ell) + arr;\n    } else {\n      const eff = BigInt(f(j - 1, arr).toString());\n\n      const tmp = j % 2 !== 0 ? ((ell + eff) % a) : ((ell + eff) % b);\n\n      return loop(j + 1, arr, tmp);\n    }\n  };\n\n  const L = m % a;\n  const R = m / a;\n\n  return loop(1, L, R);\n};\n\n/**\n * Reverse 'feis'.\n *\n * See: Black and Rogaway (2002), \"Ciphers with arbitrary finite domains.\"\n *\n * Note that this has been adjusted from the reference paper in order to\n * support some legacy behaviour.\n *\n * @param {bigint}  arg\n * @return  {bigint}\n */\nconst tail = (arg: bigint) =>\n  Fen(4, 65535n, 65536n, 0xffffffffn, F, arg);\n\nconst Fen: typeof Fe = (r, a, b, k, f, m) => {\n  const c = fen(r, a, b, f, m);\n  return (c < k) ? c : fen(r, a, b, f, c);\n};\n\nconst fen: typeof fe = (r, a, b, f, m) => {\n  const loop = (j: number, ell: bigint, arr: bigint): bigint => {\n    if (j < 1) {\n      return (a * arr) + ell;\n    } else {\n      const eff = f(j - 1, ell);\n\n      // NB (jtobin):\n      //\n      // Slight deviation from B&R (2002) here to prevent negative values.  We\n      // add 'a' or 'b' to arr as appropriate and reduce 'eff' modulo the same\n      // number before performing subtraction.\n      //\n      const tmp =\n        j % 2 !== 0\n          ? ((arr + a) - (eff % a)) % a\n          : ((arr + b) - (eff % b)) % b;\n\n      return loop(j - 1, tmp, ell);\n    }\n  };\n\n  const ahh = r % 2 !== 0 ? (m / a) : (m % a);\n\n  const ale = r % 2 !== 0 ? (m % a) : (m / a);\n\n  const L = ale === a ? ahh : ale;\n\n  const R = ale === a ? ale : ahh;\n\n  return loop(r, L, R);\n};\n\nexport default {\n  F,\n\n  fe,\n  Fe,\n  feis,\n  fein,\n\n  fen,\n  Fen,\n  tail,\n  fynd,\n};\n","import ob from './hoon/ob';\n\nexport type rank = 'czar'   | 'king' | 'duke'   | 'earl' | 'pawn';\nexport type size = 'galaxy' | 'star' | 'planet' | 'moon' | 'comet';\n\n//\n//  main parsing & rendering\n//\n\n//NOTE  matches for shape, not syllables\nexport const regexP = /^~([a-z]{3}|([a-z]{6}(\\-[a-z]{6}){0,3}(\\-(\\-[a-z]{6}){4})*))$/;\n\n/**\n * Convert a valid `@p` literal string to a bigint.\n * Throws on malformed input.\n * @param  {String}  str  certified-sane `@p` literal string\n */\nexport function parseP(str: string): bigint {\n  const syls = patp2syls(str);\n\n  const syl2bin = (idx: number) => {\n    return idx.toString(2).padStart(8, '0');  //NOTE  base16 isn't any faster\n  }\n\n  const addr = syls.reduce(\n    (acc, syl, idx) =>\n      idx % 2 !== 0 || syls.length === 1\n        ? acc + syl2bin(suffixes.indexOf(syl))\n        : acc + syl2bin(prefixes.indexOf(syl)),\n    ''\n  );\n\n  const num = BigInt('0b' + addr);\n  return ob.fynd(num);\n}\n\n/**\n * Convert a valid `@p` literal string to a bigint.\n * Returns null on malformed input.\n * @param  {String}  str  `@p` literal string\n */\nexport function parseValidP(str: string): bigint | null {\n  if (!regexP.test(str) || !validSyllables(str)) return null;\n  const res = parseP(str);\n  return (str === renderP(res)) ? res : null;\n}\n\n/**\n * Convert a number to a @p-encoded string.\n * @param  {bigint}  num\n */\nexport function renderP(num: bigint): string {\n  const sxz = ob.fein(num);\n  const dyx = Math.ceil(sxz.toString(16).length / 2);\n  const dyy = Math.ceil(sxz.toString(16).length / 4);\n\n  function loop(tsxz: bigint, timp: number, trep: string): string {\n    const log = tsxz & 0xFFFFn;\n    const pre = prefixes[Number(log >> 8n)];\n    const suf = suffixes[Number(log & 0xFFn)];\n    const etc = (timp & 0b11) ? '-' : ((timp === 0) ? '' : '--');\n\n    const res = pre + suf + etc + trep;\n\n    return timp === dyy ? trep : loop(tsxz >> 16n, timp + 1, res);\n  }\n\n  return (\n    '~' + (dyx <= 1 ? suffixes[Number(sxz)] : loop(sxz, 0, ''))\n  );\n}\n\n//\n//  utilities\n//\n\n/**\n * Validate a @p string.\n *\n * @param  {String}  str a string\n * @return  {boolean}\n */\nexport function isValidP(str: string): boolean {\n  return regexP.test(str)               //  general structure\n      && validSyllables(str)            //  valid syllables\n      && str === renderP(parseP(str));  //  no leading zeroes\n}\n\n/**\n * Determine the `$rank` of a `@p` value or literal.\n * Throws on malformed input string.\n * @param   {String}  who  `@p` value or literal string\n */\nexport function clan(who: bigint | string): rank {\n  let num: bigint;\n  if (typeof who === 'bigint') num = who;\n  else num = checkedParseP(who);\n\n  return num <= 0xFFn\n    ? 'czar'\n    : num <= 0xFFFFn\n    ? 'king'\n    : num <= 0xFFFFFFFFn\n    ? 'duke'\n    : num <= 0xFFFFFFFFFFFFFFFFn\n    ? 'earl'\n    : 'pawn';\n}\n\n/**\n * Determine the \"size\" of a `@p` value or literal.\n * Throws on malformed input string.\n * @param   {String}  who  `@p` value or literal string\n */\nexport function kind(who: bigint | string): size {\n  return rankToSize(clan(who));\n}\n\nexport function rankToSize(rank: rank): size {\n  switch (rank) {\n    case 'czar': return 'galaxy';\n    case 'king': return 'star';\n    case 'duke': return 'planet';\n    case 'earl': return 'moon';\n    case 'pawn': return 'comet';\n  }\n}\nexport function sizeToRank(size: size): rank {\n  switch (size) {\n    case 'galaxy': return 'czar';\n    case 'star':   return 'king';\n    case 'planet': return 'duke';\n    case 'moon':   return 'earl';\n    case 'comet':  return 'pawn';\n  }\n}\n\n/**\n * Determine the parent of a `@p` value.\n * Throws on malformed input string.\n * @param  {String | number}  who  `@p` value or literal string\n */\nexport function sein(who: bigint): bigint;\nexport function sein(who: string): string;\nexport function sein(who: bigint | string): typeof who {\n  let num: bigint;\n  if (typeof who === 'bigint') num = who;\n  else num = checkedParseP(who);\n\n  let mir = clan(num);\n\n  const res =\n    mir === 'czar'\n      ? num\n      : mir === 'king'\n      ? num & 0xFFn\n      : mir === 'duke'\n      ? num & 0xFFFFn\n      : mir === 'earl'\n      ? num & 0xFFFFFFFFn\n      : num & 0xFFFFn;\n\n  if (typeof who === 'bigint') return res;\n  else return renderP(res);\n}\n\n/**\n * Render short-form ship name.\n * Throws on malformed input string.\n * @param  {String | number}  who  `@p` value or literal string\n */\nexport function cite(who: bigint | string): string {\n  let num: bigint;\n  if (typeof who === 'bigint') num = who;\n  else num = checkedParseP(who);\n\n  if (num <= 0xFFFFFFFFn) {\n    return renderP(num);\n  } else if (num <= 0xFFFFFFFFFFFFFFFFn) {\n    return renderP(num & 0xFFFFFFFFn).replace('-', '^');\n  } else {\n    return renderP(BigInt('0x'+num.toString(16).slice(0,4))) + '_' + renderP(num & 0xFFFFn).slice(1);\n  }\n}\n\n//\n//  internals\n//\n\nfunction checkedParseP(str: string): bigint {\n  if (!isValidP(str)) throw new Error('invalid @p literal: ' + str);\n  return parseP(str);\n}\n\nconst pre = `\ndozmarbinwansamlitsighidfidlissogdirwacsabwissib\\\nrigsoldopmodfoglidhopdardorlorhodfolrintogsilmir\\\nholpaslacrovlivdalsatlibtabhanticpidtorbolfosdot\\\nlosdilforpilramtirwintadbicdifrocwidbisdasmidlop\\\nrilnardapmolsanlocnovsitnidtipsicropwitnatpanmin\\\nritpodmottamtolsavposnapnopsomfinfonbanmorworsip\\\nronnorbotwicsocwatdolmagpicdavbidbaltimtasmallig\\\nsivtagpadsaldivdactansidfabtarmonranniswolmispal\\\nlasdismaprabtobrollatlonnodnavfignomnibpagsopral\\\nbilhaddocridmocpacravripfaltodtiltinhapmicfanpat\\\ntaclabmogsimsonpinlomrictapfirhasbosbatpochactid\\\nhavsaplindibhosdabbitbarracparloddosbortochilmac\\\ntomdigfilfasmithobharmighinradmashalraglagfadtop\\\nmophabnilnosmilfopfamdatnoldinhatnacrisfotribhoc\\\nnimlarfitwalrapsarnalmoslandondanladdovrivbacpol\\\nlaptalpitnambonrostonfodponsovnocsorlavmatmipfip\\\n`;\n\nconst suf = `\nzodnecbudwessevpersutletfulpensytdurwepserwylsun\\\nrypsyxdyrnuphebpeglupdepdysputlughecryttyvsydnex\\\nlunmeplutseppesdelsulpedtemledtulmetwenbynhexfeb\\\npyldulhetmevruttylwydtepbesdexsefwycburderneppur\\\nrysrebdennutsubpetrulsynregtydsupsemwynrecmegnet\\\nsecmulnymtevwebsummutnyxrextebfushepbenmuswyxsym\\\nselrucdecwexsyrwetdylmynmesdetbetbeltuxtugmyrpel\\\nsyptermebsetdutdegtexsurfeltudnuxruxrenwytnubmed\\\nlytdusnebrumtynseglyxpunresredfunrevrefmectedrus\\\nbexlebduxrynnumpyxrygryxfeptyrtustyclegnemfermer\\\ntenlusnussyltecmexpubrymtucfyllepdebbermughuttun\\\nbylsudpemdevlurdefbusbeprunmelpexdytbyttyplevmyl\\\nwedducfurfexnulluclennerlexrupnedlecrydlydfenwel\\\nnydhusrelrudneshesfetdesretdunlernyrsebhulryllud\\\nremlysfynwerrycsugnysnyllyndyndemluxfedsedbecmun\\\nlyrtesmudnytbyrsenwegfyrmurtelreptegpecnelnevfes\\\n`;\n\nexport const prefixes = pre.match(/.{1,3}/g) as RegExpMatchArray;\nexport const suffixes = suf.match(/.{1,3}/g) as RegExpMatchArray;\n\nfunction patp2syls(name: string): string[] {\n  return name.replace(/[\\^~-]/g, '').match(/.{1,3}/g) || [];\n}\n\n//  check if string contains valid syllables\nfunction validSyllables(name: string): boolean {\n  const syls = patp2syls(name);\n  return !(syls.length % 2 !== 0 && syls.length !== 1)  // wrong length\n      && syls.every((syl, index) =>  //  invalid syllables\n           index % 2 !== 0 || syls.length === 1\n           ? suffixes.includes(syl)\n           : prefixes.includes(syl)\n         );\n}\n","import { prefixes, suffixes } from './p';\n\n//TODO  investigate whether native UintArrays are more portable\n//      than node Buffers\n\n/**\n * Convert a number to a `@q`-encoded string.\n * @param   {bigint}  num\n * @return  {String}\n */\nexport function renderQ(num: bigint): string {\n  //NOTE  stupid hack to work around bad node Buffer spec\n  const hex = num.toString(16);\n  const lex = hex.length;\n  const buf = Buffer.from(hex.padStart(lex+lex%2, '0'), 'hex');\n  const chunked =\n    buf.length % 2 !== 0 && buf.length > 1\n      ? [[buf[0]]].concat(chunk(Array.from(buf.slice(1)), 2))\n      : chunk(Array.from(buf), 2);\n\n  const prefixName = (byts: number[]) =>\n    byts[1] === undefined\n      ? suffixes[byts[0]]\n      : prefixes[byts[0]] + suffixes[byts[1]];  //TODO  this branch unused\n\n  const name = (byts: number[]) =>\n    byts[1] === undefined\n      ? suffixes[byts[0]]\n      : prefixes[byts[0]] + suffixes[byts[1]];\n\n  const alg = (pair: number[]) =>\n    pair.length % 2 !== 0 && chunked.length > 1 ? prefixName(pair) : name(pair);\n\n  return chunked.reduce(\n    (acc, elem) => acc + (acc === '.~' ? '' : '-') + alg(elem),\n    '.~'\n  );\n}\n\n/**\n * Convert a `@q`-encoded string to a bigint.\n * Throws on malformed input.\n * @param   {String}  str `@q` string with leading .~\n * @return  {String}\n */\nexport function parseQ(str: string): bigint {\n  const chunks = str.slice(2).split('-');\n  const dec2hex = (dec: number) => {\n    if (dec < 0) throw new Error('malformed @q');\n    return dec.toString(16).padStart(2, '0');\n  }\n\n  const splat = chunks.map((chunk, i) => {\n    let syls = splitAt(3, chunk);\n    return (syls[1] === '' && i === 0)  //  singles only at the start\n      ? dec2hex(suffixes.indexOf(syls[0]))\n      : dec2hex(prefixes.indexOf(syls[0])) + dec2hex(suffixes.indexOf(syls[1]));\n  });\n\n  return BigInt('0x' + (str.length === 0 ? '00' : splat.join('')));\n}\n\nexport function parseValidQ(str: string): bigint | null {\n  try {\n    const num = parseQ(str);\n    return num;\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Validate a `@q` string.\n * @param   {String}  str  a string\n * @return  {boolean}\n */\nexport function isValidQ(str: string): boolean {\n  if (str === '') return false;\n  try {\n    parseQ(str);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n//\n//  internals\n//\n\nfunction chunk<T>(arr: T[], size: number): T[][] {\n  let chunk: T[] = [];\n  let newArray = [chunk];\n\n  for (let i = 0; i < arr.length; i++) {\n    if (chunk.length < size) {\n      chunk.push(arr[i]);\n    } else {\n      chunk = [arr[i]];\n      newArray.push(chunk);\n    }\n  }\n\n  return newArray;\n}\n\nfunction splitAt(index: number, str: string) {\n  return [str.slice(0, index), str.slice(index)];\n}\n","export type precision = 'h' | 's' | 'd' | 'q' | precisionBits;\ntype precisionBits = { w: number, p: number, l: string };\n\n//  str: @r* format string including its leading . and ~s\nexport function parseR(per: precision, str: string): bigint {\n  per = getPrecision(per);\n  return parse(str.slice(per.l.length), per.w, per.p);\n}\n\nexport function renderR(per: precision, r: bigint): string {\n  per = getPrecision(per);\n  return per.l + rCo(deconstruct(r, BigInt(per.w), BigInt(per.p)));\n}\n\n//\n//  helpers\n//\n\nfunction getPrecision(per: precision): precisionBits {\n  if (per === 'h') return { w:  5, p:  10, l: '.~~'  }; else\n  if (per === 's') return { w:  8, p:  23, l: '.'    }; else\n  if (per === 'd') return { w: 11, p:  52, l: '.~'   }; else\n  if (per === 'q') return { w: 15, p: 112, l: '.~~~' }; else\n  return per;\n}\n\nfunction bitMask(bits: bigint): bigint {\n  return (2n ** bits) - 1n;\n}\n\n//\n//  parsing and construction\n//\n\n//  str: @r* format string with its leading . and ~ stripped off\n//  w:   exponent bits\n//  p:   mantissa bits\nfunction parse(str: string, w: number, p: number): bigint {\n  if (str === 'nan')  return makeNaN(w, p);\n  if (str === 'inf')  return makeInf(true, w, p);\n  if (str === '-inf') return makeInf(false, w, p);\n  let i = 0;\n  let sign = true;\n  if (str[i] === '-') {\n    sign = false;\n    i++;\n  }\n  let int = '';\n  while (str[i] !== '.' && str[i] !== 'e' && str[i] !== undefined) {\n    int += str[i++];\n  }\n  if (str[i] === '.') i++;\n  let fra = '';\n  while (str[i] !== 'e' && str[i] !== undefined) {\n    fra += str[i++];\n  }\n  if (str[i] === 'e') i++;\n  let expSign = true;\n  if (str[i] === '-') {\n    expSign = false;\n    i++;\n  }\n  let exp = '';\n  while (str[i] !== undefined) {\n    exp += str[i++];\n  }\n  return BigInt('0b' + makeFloat(w, p, sign, int, fra, expSign, Number(exp)));\n}\n\nfunction makeNaN(w: number, p: number): bigint {\n  return bitMask(BigInt(w + 1)) << BigInt(p - 1);\n}\n\nfunction makeInf(s: boolean, w: number, p: number): bigint {\n  return bitMask(BigInt(s ? w : w + 1)) << BigInt(p);\n}\n\n//  turn into representation without exponent\nfunction makeFloat(w: number, p: number, sign: boolean, intPart: string, floatPart: string, expSign: boolean, exp: number) {\n  if (exp !== 0) {\n    if (expSign) {\n      intPart = intPart + floatPart.padEnd(exp, '0').slice(0, exp);\n      floatPart = floatPart.slice(exp);\n    } else {\n      floatPart = intPart.padStart(exp, '0').slice(-exp) + floatPart;\n      intPart = intPart.slice(0, -exp);\n    }\n  }\n  return construct(p, w, sign, BigInt(intPart), BigInt(floatPart.length), BigInt(floatPart));\n}\n\n//NOTE  modified from an encodeFloat() written by by Jonas Raoni Soares Silva,\n//      made to operate on (big)integers, without using js's float logic.\n//      http://jsfromhell.com/classes/binary-parser\n//      (yes, this code is vaguely deranged. but it works!)\nfunction construct(precisionBits: number, exponentBits: number,\n                   sign: boolean, intPart: bigint, floatDits: bigint, floatPart: bigint) {\n  //REVIEW  when do we trigger this?\n  //        inputs representing nrs too large for exponentBits?\n  //        inputs with precision we can't match?\n  //        add tests for those cases! should match stdlib result.\n  function exceed(x: string) {\n    console.warn(x);\n    return 1;\n  }\n\n  const bias = 2**(exponentBits - 1) - 1,\n    minExp = -bias + 1,\n    maxExp = bias,\n    minUnnormExp = minExp - precisionBits,\n    len = 2 * bias + 1 + precisionBits + 3,\n    bin = new Array(len),\n    denom = 10n ** floatDits;\n  var exp = 0,\n    signal = !sign,\n    i, lastBit, rounded, j, result, n;\n  //  zero-initialize the bit-array\n  for (i = len; i; bin[--i] = 0);\n  //  integral into bits\n  for (i = bias + 2; intPart && i; bin[--i] = intPart & 1n, intPart = intPart >> 1n);\n  //  fractional into bits\n  for (i = bias + 1; floatPart > 0n && (i < len); (bin[++i] = (((floatPart *= 2n) >= denom) ? 1 : 0)) && (floatPart = floatPart - denom));\n  //  walk cursor (i) to first 1-bit.\n  for (i = -1; ++i < len && !bin[i];);\n  //  round if needed\n  if (bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1))) + 1]) {\n    if (!(rounded = bin[lastBit]))\n      for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]);\n    for (j = lastBit + 1; rounded && --j >= 0; (bin[j] = (!bin[j] ? 1 : 0) - 0) && (rounded = 0));\n  }\n  //  walk cursor (i) to first/next(??) 1-bit\n  for (i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];);\n\n  //  set exponent, throwing on under- and overflows\n  (exp = bias + 1 - i) >= minExp && exp <= maxExp ? ++i : exp < minExp &&\n    (exp != bias + 1 - len && exp < minUnnormExp && exceed('r.construct underflow'), i = bias + 1 - (exp = minExp - 1));\n  intPart && (exceed(intPart ? 'r.construct overflow' : 'r.construct'),\n    exp = maxExp + 1, i = bias + 2);\n  //  exponent into bits\n  for (n = Math.abs(exp + bias), j = exponentBits + 1, result = ''; --j; result = (n & 1) + result, n = n >>= 1);\n  //  final serialization: sign + exponent + mantissa\n  return (signal ? '1' : '0') + result + bin.slice(i, i + precisionBits).join('');\n};\n\n//\n//  deconstruction and rendering\n//\n\ntype dn = { t: 'd', s: boolean, e: number, a: string }\n        | { t: 'i', s: boolean }\n        | { t: 'n' };\n\n//NOTE  not _exactly_ like +r-co due to dragon4() outExponent semantics.\n//      if we copy +r-co logic exactly we off-by-one all over the place.\nfunction rCo(a: dn): string {\n  if (a.t === 'n') return 'nan';\n  if (a.t === 'i') return a.s ? 'inf' : '-inf';\n  let e: number;\n  if ((a.e - 4) > 0) {  //  12000 -> 12e3 e>+2\n    e = 1;\n  } else\n  if ((a.e + 2) < 0) {  //  0.001 -> 1e-3 e<-2\n    e = 1;\n  } else {  //  1.234e2 -> '.'@3 -> 123 .4\n    e = a.e + 1;\n    a.e = 0;\n  }\n  return (a.s ? '' : '-')\n       + edCo(e, a.a)\n       + ((a.e === 0) ? '' : ('e' + a.e.toString()));\n}\n\nfunction edCo(exp: number, int: string): string {\n  const dig: number = Math.abs(exp);\n  if (exp <= 0) {\n    return '0.' + (''.padEnd(dig, '0')) + int;\n  } else {\n    const len = int.length;\n    if (dig >= len) return int + ''.padEnd((dig - len), '0');\n    return int.slice(0, dig) + '.' + int.slice(dig);\n  }\n}\n\n//NOTE  the deconstruct() and dragon4() below are ported from Ryan Juckett's\n//      PrintFloat32() and Dragon4() respectively. its general structure is\n//      copied one-to-one and comments are preserved, but we got to drop some\n//      logic due to having access to native bigints. see his post series for\n//      a good walkthrough of the underlying algorithm and its implementation,\n//      as well as pointers to additional references.\n//      https://www.ryanjuckett.com/printing-floating-point-numbers/\n//      we only use one of the cutoff modes, but have maintained support for\n//      the others for completeness' sake.\n\n//  deconstruct(): binary float to $dn structure (+drg:ff)\nfunction deconstruct(float: bigint, exponentBits: bigint, precisionBits: bigint): dn {\n  //  deconstruct the value into its components\n  const mantissaMask = bitMask(precisionBits);\n  const exponentMask = bitMask(exponentBits);\n  const floatMantissa: bigint = float & mantissaMask;\n  const floatExponent: bigint = (float >> BigInt(precisionBits)) & exponentMask;\n  const sign: boolean = ((float >> BigInt(exponentBits + precisionBits)) & 1n) === 0n;\n\n  //  transform the components into the values they represent\n  let mantissa: bigint, exponent: bigint, mantissaHighBitIdx: number, unequalMargins: boolean;\n  if (floatExponent === exponentMask) {  //  specials\n    if (floatMantissa === 0n)\n      return { t: 'i', s: sign };  //  infinity\n    return { t: 'n' };  //  nan\n  } else\n  if (floatExponent !== 0n) {  //  normalized\n    //  the floating point equation is:\n    //    value = (1 + mantissa/2^23) * 2 ^ (exponent-127)\n    //  we convert the integer equation by factoring a 2^23 out of the exponent\n    //    value = (1 + mantissa/2^23) * 2^23 * 2 ^ (exponent-127-23)\n    //    value = (2^23 + mantissa) * 2 ^ (exponent-127-23)\n    //  because of the implied 1 in front of the mantissa we have 24 bits of precision\n    //    m = (2^23 + mantissa)\n    //    e = (exponent-127-23)\n    mantissa = (1n << BigInt(precisionBits)) | floatMantissa;\n    exponent = floatExponent - ((2n**(exponentBits-1n))-1n) - precisionBits;\n    mantissaHighBitIdx = Number(precisionBits);\n    unequalMargins = (floatExponent !== 1n) && (floatMantissa === 0n);\n  } else {  //  denormalized\n    //  the floating point equation is:\n    //    value = (mantissa/2^23) * 2 ^ (1-127)\n    //  we convert the integer equation by factoring a 2^23 out of the exponent\n    //    value = (mantissa/2^23) * 2^23 * 2 ^ (1-127-23)\n    //    value = mantissa * 2 ^ (1-127-23)\n    //  we have up to 23 bits of precision\n    //    m = (mantissa)\n    //    e = (1-127-23)\n    mantissa = floatMantissa;\n    exponent = 1n - ((2n**(exponentBits-1n))-1n) - precisionBits;\n    mantissaHighBitIdx = mantissa.toString(2).length - 1;  //  poor man's log2\n    unequalMargins = false;\n  }\n\n  const buf = (2n**precisionBits).toString(10).length + 1;\n  const res = dragon4(mantissa, Number(exponent), mantissaHighBitIdx, unequalMargins, 'unique', 0, buf);\n  return { t: 'd', s: sign, e: res.outExponent, a: res.digits };\n}\n\n//  dragon4(): binary float to decimal digits\n//\n//    like +drg:fl (but with slightly different outExponent semantics)\n//\n//    mantissa:           value significand\n//    exponent:           value exponent in base 2\n//    mantissaHighBitIdx: highest set mantissa bit index\n//    hasUnequalMargins:  is the high margin twice the low margin\n//    cutoffMode:         'unique' | 'totalLength' | 'fractionLength'\n//    cutoffNumber:       cutoff parameter for the selected mode\n//    bufferSize:         max output digits\n//\n//    digits:             printed digits\n//    outExponent:        exponent of the first digit printed\n//\nfunction dragon4(\n  mantissa: bigint,\n  exponent: number,\n  mantissaHighBitIdx: number,\n  hasUnequalMargins: boolean,\n  cutoffMode: 'unique' | 'totalLength' | 'fractionLength',\n  cutoffNumber: number,\n  bufferSize: number\n): { digits: string, outExponent: number } {\n  const bexponent = BigInt(exponent);\n  let pCurDigit = 0;  //  pointer into output buffer (digit string index)\n  let outBuffer = new Array(bufferSize).fill('0');\n  let outExponent = 0;\n\n  //  if mantissa is zero, output \"0\"\n  if (mantissa === 0n) {\n    outBuffer[0] = '0';\n    outExponent = 0;\n    return { digits: outBuffer.slice(0, 1).join(''), outExponent };\n  }\n\n  //  compute the initial state in integral form such that:\n  //  value     = scaledValue / scale\n  //  marginLow = scaledMarginLow / scale\n\n  let scale: bigint;             //  positive scale applied to value and margin such\n                                 //  that they can be represented as whole numbers\n  let scaledValue: bigint;       //  scale * mantissa\n  let scaledMarginLow: bigint;   //  scale * 0.5 * (distance between this floating-\n                                 //  point number and its immediate lower value)\n\n  //  for normalized IEEE floating point values, each time the exponent is\n  //  incremented the margin also doubles. That creates a subset of transition\n  //  numbers where the high margin is twice the size of the low margin.\n  let scaledMarginHigh: bigint;\n\n  if (hasUnequalMargins) {\n    if (exponent > 0) {  //  no fractional component\n      //  1. expand the input value by multiplying out the mantissa and exponent.\n      //     this represents the input value in its whole number representation.\n      //  2. apply an additional scale of 2 such that later comparisons against\n      //     the margin values are simplified.\n      //  3. set the margin value to the lowest mantissa bit's scale.\n\n      scaledValue = 4n * mantissa;\n      scaledValue <<= bexponent;              //  2 * 2 * mantissa*2^exponent\n      scale = 4n;                             //  2 * 2 * 1\n      scaledMarginLow = 1n << bexponent;      //  2 * 2^(exponent-1)\n      scaledMarginHigh = 1n << bexponent+1n;  //  2 * 2 * 2^(exponent-1)\n    } else {  //  fractional component\n      //  in order to track the mantissa data as an integer, we store it as is\n      //  with a large scale\n\n      scaledValue = 4n * mantissa;  //  2 * 2 * mantissa\n      scale = 1n << -bexponent+2n;  //  2 * 2 * 2^(-exponent)\n      scaledMarginLow = 1n;         //  2 * 2^(-1)\n      scaledMarginHigh = 2n;        //  2 * 2 * 2^(-1)\n    }\n  } else {\n    if (exponent > 0) {  //  no fractional component\n      //  1. expand the input value by multiplying out the mantissa and exponent.\n      //     this represents the input value in its whole number representation.\n      //  2. apply an additional scale of 2 such that later comparisons against\n      //     the margin values are simplified.\n      //  3. set the margin value to the lowest mantissa bit's scale.\n\n      scaledValue = 2n * mantissa;\n      scaledValue <<= bexponent;          //  2 * mantissa*2^exponent\n      scale = 2n;                         //  2 * 1\n      scaledMarginLow = 1n << bexponent;  //  2 * 2^(exponent-1)\n      scaledMarginHigh = scaledMarginLow;\n    } else {  //  fractional component\n      //  in order to track the mantissa data as an integer, we store it as is\n      //  with a large scale\n\n      scaledValue = 2n * mantissa;          //  2 * mantissa\n      scale = 1n << BigInt(-exponent + 1);  //  2 * 2^(-exponent)\n      scaledMarginLow = 1n;                 //  2 * 2^(-1)\n      scaledMarginHigh = scaledMarginLow;\n    }\n  }\n\n  //  compute an estimate for digitExponent that will be correct or undershoot\n  //  by one. this optimization is based on the paper \"Printing Floating-Point\n  //  Numbers Quickly and Accurately\" by Burger and Dybvig.\n  //  http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.4656&rep=rep1&type=pdf\n  //  we perform an additional subtraction of 0.69 to increase the frequency of\n  //  a failed estimate because that lets us take a faster branch in the code.\n  //  0.69 is chosen because 0.69 + log10(2) is less than one by a reasonable\n  //  epsilon that will account for any floating point error.\n\n  //  we want to set digitExponent to floor(log10(v)) + 1\n  //  v = mantissa*2^exponent\n  //  log2(v) = log2(mantissa) + exponent;\n  //  log10(v) = log2(v) * log10(2)\n  //  floor(log2(v)) = mantissaHighBitIdx + exponent;\n  //  log10(v) - log10(2) < (mantissaHighBitIdx + exponent) * log10(2) <= log10(v)\n  //  log10(v) < (mantissaHighBitIdx + exponent) * log10(2) + log10(2) <= log10(v) + log10(2)\n  //  floor( log10(v) ) < ceil( (mantissaHighBitIdx + exponent) * log10(2) ) <= floor( log10(v) ) + 1\n  //NOTE  loses precision! wants a 64-bit float. but seems precise enough...\n  const log10_2 = 0.30102999566398119521373889472449;\n  let digitExponent = Math.ceil((mantissaHighBitIdx + exponent) * log10_2 - 0.69);\n\n  //  if the digit exponent is smaller than the smallest desired digit for\n  //  fractional cutoff, pull the digit back into legal range at which point we\n  //  will round to the appropriate value.\n  //  note that while our value for digitExponent is still an estimate, this is\n  //  safe because it only increases the number. this will either correct\n  //  digitExponent to an accurate value or it will clamp it above the accurate\n  //  value.\n  if (cutoffMode === 'fractionLength' && digitExponent <= -cutoffNumber) {\n    digitExponent = -cutoffNumber + 1;\n  }\n\n  //  scale adjustment for digit exponent, divide value by 10^digitExponent\n  if (digitExponent > 0) {\n    //  the exponent is positive creating a division so we multiply up the scale\n    scale *= BigInt(10) ** BigInt(digitExponent);\n  } else if (digitExponent < 0) {\n    //  the exponent is negative creating a multiplication so we multiply\n    //  up the scaledValue, scaledMarginLow and scaledMarginHigh\n    const pow10 = BigInt(10) ** BigInt(-digitExponent);\n    scaledValue *= pow10;\n    scaledMarginLow *= pow10;\n    if (scaledMarginHigh !== scaledMarginLow) {\n      scaledMarginHigh *= scaledMarginLow;\n    }\n  }\n\n  //  if (value >= 1), our estimate for digitExponent was too low\n  if (scaledValue >= scale) {\n    //  the exponent estimate was incorrect. increment the exponent and don't\n    //  perform the premultiply needed for the first loop iteration.\n    digitExponent += 1;\n  } else {\n    //  the exponent estimate was correct. multiply larger by the output base\n    //  to prepare for the first loop iteration.\n    scaledValue *= 10n;\n    scaledMarginLow *= 10n;\n    if (scaledMarginHigh !== scaledMarginLow) scaledMarginHigh *= 10n;\n  }\n\n  //  compute the cutoff exponent (the exponent of the final digit to print).\n  //  default to the maximum size of the output buffer.\n  let cutoffExponent = digitExponent - bufferSize;\n  if (cutoffMode === 'totalLength') {\n    let desired = digitExponent - cutoffNumber;\n    if (desired > cutoffExponent) cutoffExponent = desired;\n  } else if (cutoffMode === 'fractionLength') {\n    let desired = -cutoffNumber;\n    if (desired > cutoffExponent) cutoffExponent = desired;\n  }\n\n  //  output the exponent of the first digit we will print\n  outExponent = digitExponent - 1;\n\n  //NOTE  thanks to native bigints, no bit block normalization needed\n\n  //  these values are used to inspect why the print loop terminated so we can properly\n  //  round the final digit.\n  let low = false;      //  did the value get within marginLow distance from zero\n  let high = false;     //  did the value get within marginHigh distance from one\n  let outputDigit = 0;  //  current digit being output\n\n  if (cutoffMode === 'unique') {\n    //  for the unique cutoff mode, we will try to print until we have reached\n    //  a level of precision that uniquely distinguishes this value from its\n    //  neighbors. if we run out of space in the output buffer, we exit early.\n\n    while (true) {\n      digitExponent -= 1;\n\n      //  extract the digit\n      outputDigit = Number(scaledValue / scale);\n      scaledValue = scaledValue % scale;\n\n      //  update the high end of the value\n      let scaledValueHigh = scaledValue + scaledMarginHigh;\n\n      //  stop looping if we are far enough away from our neighboring values\n      //  or if we have reached the cutoff digit\n      low = scaledValue < scaledMarginLow;\n      high = scaledValueHigh > scale;\n      if (low || high || (digitExponent === cutoffExponent)) break;\n\n      //  store the output digit\n      outBuffer[pCurDigit] = String.fromCharCode('0'.charCodeAt(0) + outputDigit);\n      pCurDigit += 1;\n\n      //  mulitply larger by the output base\n      scaledValue *= 10n;\n      scaledMarginLow *= 10n;\n      if (scaledMarginHigh !== scaledMarginLow) scaledMarginHigh *= 10n;\n    }\n  } else {\n    //  for length based cutoff modes, we will try to print until we have\n    //  exhausted all precision (i.e. all remaining digits are zeros) or until\n    //  we reach the desired cutoff digit.\n\n    low = false;\n    high = false;\n    while (true) {\n      digitExponent -= 1;\n\n      //  extract the digit\n      outputDigit = Number(scaledValue / scale);\n      scaledValue = scaledValue % scale;\n\n      if (scaledValue === 0n || digitExponent === cutoffExponent) break;\n\n      //  store the output digit\n      outBuffer[pCurDigit] = String.fromCharCode('0'.charCodeAt(0) + outputDigit);\n      pCurDigit += 1;\n\n      //  multiply larger by the output base\n      scaledValue *= 10n;\n    }\n  }\n\n  //  round off the final digit.\n  //  default to rounding down if value got too close to 0\n  let roundDown = low;\n\n  if (low === high) {  //  legal to round up and down\n    //  round to the closest digit by comparing value with 0.5. to do this we\n    //  need to convert the inequality to large integer values.\n    //  compare( value, 0.5 )\n    //  compare( scale * value, scale * 0.5 )\n    //  compare( 2 * scale * value, scale )\n    scaledValue *= 2n;\n    let compare = scaledValue < scale ? -1\n                : (scaledValue > scale ? 1 : 0);\n    roundDown = compare < 0;\n    //  if we are directly in the middle, round towards the even digit\n    //  (i.e. IEEE rouding rules)\n    if (compare === 0) roundDown = (outputDigit & 1) === 0;\n  }\n\n  //  print the rounded digit\n  if (roundDown) {\n    outBuffer[pCurDigit] = String.fromCharCode('0'.charCodeAt(0) + outputDigit);\n    pCurDigit += 1;\n  } else {\n    //  handle rounding up\n    if (outputDigit === 9) {\n      //  find the first non-nine prior digit\n      while (true) {\n        if (pCurDigit === 0) {  //  first digit\n          //  output 1 at the next highest exponent\n          outBuffer[pCurDigit] = '1';\n          pCurDigit += 1;\n          outExponent += 1;\n          break;\n        }\n        pCurDigit -= 1;\n        if (outBuffer[pCurDigit] !== '9') {\n          //  increment the digit\n          outBuffer[pCurDigit] = String.fromCharCode(outBuffer[pCurDigit].charCodeAt(0) + 1);\n          pCurDigit += 1;\n          break;\n        }\n      }\n    } else {\n      //  values in the range [0,8] can perform a simple round up\n      outBuffer[pCurDigit] = String.fromCharCode('0'.charCodeAt(0) + outputDigit + 1);\n      pCurDigit += 1;\n    }\n  }\n\n  //  trim trailing zeroes, produce output\n  const digits = outBuffer.slice(0, pCurDigit).join('');\n  return { digits, outExponent };\n}\n","//  parse: deserialize from atom literal strings\n//\n//    atom literal parsing from hoon 137 (and earlier).\n//    stdlib arm names are included for ease of cross-referencing.\n//\n//TODO  unsupported auras: @dr, @uc\n\nimport { aura, dime, coin } from './types';\n\nimport { parseDa, parseDr } from './d';\nimport { parseValidP, regexP } from './p';\nimport { parseValidQ } from './q';\nimport { parseR, precision } from './r';\n\nfunction integerRegex(a: string, b: string, c: string, d: number, e: boolean = false): RegExp {\n  const pre = d === 0 ? b       : `${b}${c}{0,${d-1}}`;\n  const aft = d === 0 ? `${c}*` : `(\\\\.${c}{${d}})*`;\n  return new RegExp(`^${e ? '\\\\-\\\\-?' : ''}${a}(0|${pre}${aft})$`);\n}\n\nfunction floatRegex(a: number): RegExp {\n  return new RegExp(`^\\\\.~{${a}}(nan|\\\\-?(inf|(0|[1-9][0-9]*)(\\\\.[0-9]+)?(e\\\\-?(0|[1-9][0-9]*))?))$`);\n}\n\n//TODO  rewrite with eye towards capturing groups?\nexport const regex: { [key in aura]: RegExp } = {\n  'c':   /^~\\-((~[0-9a-fA-F]+\\.)|(~[~\\.])|[0-9a-z\\-\\._])*$/,\n  'da':  /^~(0|[1-9][0-9]*)\\-?\\.0*([1-9]|1[0-2])\\.0*[1-9][0-9]*(\\.\\.([0-9]+)\\.([0-9]+)\\.([0-9]+)(\\.(\\.[0-9a-f]{4})+)?)?$/,\n  'dr':  /^~((d|h|m|s)(0|[1-9][0-9]*))(\\.(d|h|m|s)(0|[1-9][0-9]*))*(\\.(\\.[0-9a-f]{4})+)?$/,  //TODO  first ? to * mb\n  'f':   /^\\.(y|n)$/,\n  'if':  /^(\\.(0|[1-9][0-9]{0,2})){4}$/,\n  'is':  /^(\\.(0|[1-9a-fA-F][0-9a-fA-F]{0,3})){8}$/,\n  'n':   /^~$/,\n  'p':   regexP,  //NOTE  matches shape but not syllables\n  'q':   /^\\.~(([a-z]{3}|[a-z]{6})(\\-[a-z]{6})*)$/,  //NOTE  matches shape but not syllables\n  'rd':  floatRegex(1),\n  'rh':  floatRegex(2),\n  'rq':  floatRegex(3),\n  'rs':  floatRegex(0),\n  'sb':  integerRegex('0b', '1', '[01]', 4, true),\n  'sd':  integerRegex('', '[1-9]', '[0-9]', 3, true),\n  'si':  integerRegex('0i', '[1-9]', '[0-9]', 0, true),\n  'sv':  integerRegex('0v', '[1-9a-v]', '[0-9a-v]', 5, true),\n  'sw':  integerRegex('0w', '[1-9a-zA-Z~-]', '[0-9a-zA-Z~-]', 5, true),\n  'sx':  integerRegex('0x', '[1-9a-f]', '[0-9a-f]', 4, true),\n  't':   /^~~((~[0-9a-fA-F]+\\.)|(~[~\\.])|[0-9a-z\\-\\._])*$/,\n  'ta':  /^~\\.[0-9a-z\\-\\.~_]*$/,\n  'tas': /^[a-z][a-z0-9\\-]*$/,\n  'ub':  integerRegex('0b', '1', '[01]', 4),\n  'ud':  integerRegex('', '[1-9]', '[0-9]', 3),\n  'ui':  integerRegex('0i', '[1-9]', '[0-9]', 0),\n  'uv':  integerRegex('0v', '[1-9a-v]', '[0-9a-v]', 5),\n  'uw':  integerRegex('0w', '[1-9a-zA-Z~-]', '[0-9a-zA-Z~-]', 5),\n  'ux':  integerRegex('0x', '[1-9a-f]', '[0-9a-f]', 4),\n};\n\n//  parse(): slav()\n//  slav(): slaw() but throwing on failure\n//\nexport const parse = slav;\nexport default parse;\nexport function slav(aura: aura, str: string): bigint {\n  const out = slaw(aura, str);\n  if (!out) {\n    throw new Error('slav: failed to parse @' + aura + ' from string: ' + str);\n  }\n  return out;\n}\n\n//  tryParse(): slaw()\n//  slaw(): parse string as specific aura, null if that fails\n//\nexport const tryParse = slaw;\nexport function slaw(aura: aura, str: string): bigint | null {\n  //  if the aura has a regex, test with that first\n  //TODO  does double work with checks in nuck?\n  //\n  if (aura in regex && !regex[aura as aura].test(str)) {\n    return null;\n  }\n  //  proceed into parsing the string into a coin,\n  //  producing a result if the aura matches\n  //\n  //TODO  further short-circuit based on aura?\n  const coin = nuck(str);\n  if (coin && coin.type === 'dime' && coin.aura === aura) {\n    return coin.atom;\n  } else {\n    return null;\n  }\n}\n\nexport function valid(aura: aura, str: string): boolean {\n  return slaw(aura, str) !== null;\n}\n\n//  nuck(): parse string into coin, or null if that fails\n//\nexport function nuck(str: string): coin | null {\n  if (str === '') return null;\n\n  //  narrow options down by the first character, before doing regex tests\n  //  and trying to parse for real\n  //\n  const c = str[0];\n  if (c >= 'a' && c <= 'z') {  //  \"sym\"\n    if (regex['tas'].test(str)) {\n      return { type: 'dime', aura: 'tas', atom: stringToCord(str) };\n    } else {\n      return null;\n    }\n  } else\n  if (c >= '0' && c <= '9') {  //  \"bisk\"\n    const dim = bisk(str);\n    if (!dim) {\n      return null;\n    } else {\n      return { type: 'dime', ...dim };\n    }\n  } else\n  if (c === '-') {  //  \"tash\"\n    let pos = true;\n    if (str[1] == '-') {\n      str = str.slice(2);\n    } else {\n      str = str.slice(1);\n      pos = false;\n    }\n    const dim = bisk(str);\n    if (dim) {\n      // `@s`?:(pos (mul 2 b) ?:(=(0 b) 0 +((mul 2 (dec b)))))\n      if (pos) {\n        dim.atom = 2n * dim.atom;\n      } else if (dim.atom !== 0n) {\n        dim.atom = 1n + (2n * (dim.atom - 1n));\n      }\n      //NOTE  assumes bisk always returns u* auras\n      return { type: 'dime', aura: dim.aura.replace('u', 's') as aura, atom: dim.atom };\n    } else {\n      return null;\n    }\n  } else\n  if (c === '.') {  //  \"perd\", \"zust\"\n    //NOTE  doesn't match stdlib parsing order, but they're easy early-outs\n    if (str === '.y') {\n      return { type: 'dime', aura: 'f', atom: 0n };\n    } else\n    if (str === '.n') {\n      return { type: 'dime', aura: 'f', atom: 1n };\n    } else\n    //REVIEW  entering the branch this way assumes regexes for sequentially-tested auras don't overlap...\n    //        going down the list of options this way matches hoon parser behavior the closest, but is slow for the \"miss\" case.\n    //        could be optimized by hard-returning if the regex fails for cases where the lead char is unique.\n    //        should probably run some perf tests\n    if (regex['is'].test(str)) {\n      const value = str.slice(1).split('.').reduce((a, v) => a + v.padStart(4, '0'), '');\n      return { type: 'dime', aura: 'is', atom: BigInt('0x'+value) };\n    } else\n    if (regex['if'].test(str)) {\n      const value = str.slice(1).split('.').reduce((a, v, i) => (a + (BigInt(v) << BigInt(8 * (3 - i)))), 0n);\n      return { type: 'dime', aura: 'if', atom: value };\n    } else\n    if ( ( str[1] === '~' &&\n           (regex['rd'].test(str) || regex['rh'].test(str) || regex['rq'].test(str)) )\n      || regex['rs'].test(str) ) {  //  \"royl\"\n      let precision = 0;\n      while (str[precision+1] === '~') precision++;\n      let aura: aura;\n      switch (precision) {\n        case 0: aura = 'rs'; break;\n        case 1: aura = 'rd'; break;\n        case 2: aura = 'rh'; break;\n        case 3: aura = 'rq'; break;\n        default: throw new Error('parsing invalid @r*');\n      }\n      return { type: 'dime', aura, atom: parseR(aura[1] as precision, str) };\n    } else\n    if (str[1] === '~' && regex['q'].test(str)) {\n      const num = parseValidQ(str);\n      if (num === null) return null;\n      return { type: 'dime', aura: 'q', atom: num };\n    } else\n    if (str[1] === '_' && /^\\.(_([0-9a-zA-Z\\-\\.]|~\\-|~~)+)*__$/.test(str)) {  //  \"nusk\"\n      const coins = str.slice(1, -2).split('_').slice(1).map((s): coin | null => {\n        //NOTE  real +wick produces null for strings w/ other ~ chars,\n        //      but the regex above already excludes those\n        s = s.replaceAll('~-', '_').replaceAll('~~', '~');  //  \"wick\"\n        return nuck(s);\n      });\n      if (coins.some(c => c === null)) {\n        return null;\n      } else {\n        return { type: 'many', list: coins as coin[] };\n      }\n    }\n    return null;\n  } else\n  if (c === '~') {\n    if (str === '~') {\n      return { type: 'dime', aura: 'n', atom: 0n }\n    } else {  //  \"twid\"\n      if (regex['da'].test(str)) {\n        return { type: 'dime', aura: 'da', atom: parseDa(str) };\n      } else\n      if (regex['dr'].test(str)) {\n        return { type: 'dime', aura: 'dr', atom: parseDr(str) };\n      } else\n      if (regex['p'].test(str)) {\n        //NOTE  this still does the regex check twice...\n        const res = parseValidP(str);\n        if (res === null) return null;\n        return { type: 'dime', aura: 'p', atom: res };\n      } else\n      //TODO  test if these single-character checks affect performance or no,\n      //      or if we want to move them further up, etc.\n      if (str[1] === '.' && regex['ta'].test(str)) {\n        return { type: 'dime', aura: 'ta', atom: stringToCord(str.slice(2)) };\n      } else\n      if (str[1] === '~' && regex['t'].test(str)) {\n        return { type: 'dime', aura: 't', atom: stringToCord(decodeString(str.slice(2))) };\n      } else\n      if (str[1] === '-' && regex['c'].test(str)) {\n        //TODO  cheeky! this doesn't support the full range of inputs that the\n        //      hoon stdlib supports, but should work for all sane inputs.\n        //      no guarantees about behavior for insane inputs...\n        if (/^~\\-~[0-9a-f]+\\.$/.test(str)) {\n          return { type: 'dime', aura: 'c', atom: BigInt('0x' + str.slice(3, -1)) };\n        }\n        return { type: 'dime', aura: 'c', atom: stringToCord(decodeString(str.slice(2))) };\n      }\n    }\n    if ((str[1] === '0') && /^~0[0-9a-v]+$/.test(str)) {\n      return { type: 'blob', jam: slurp(5, UV_ALPHABET, str.slice(2)) };\n    }\n    return null;\n  }\n  return null;\n}\n\n//  bisk(): parse string into dime of integer aura, or null if that fails\n//\nfunction bisk(str: string): dime | null {\n  switch (str.slice(0, 2)) {\n    case '0b':  //  \"bay\"\n      if (regex['ub'].test(str)) {\n        return { aura: 'ub', atom: BigInt(str.replaceAll('.', '')) };\n      } else {\n        return null;\n      }\n\n    case '0c':  //  \"fim\"\n      //TODO  support base58check\n      console.log('aura-js: @uc parsing unsupported (bisk)');\n      return null;\n\n    case '0i':  //  \"dim\"\n      if (regex['ui'].test(str)) {\n        return { aura: 'ui', atom: BigInt(str.slice(2)) }\n      } else {\n        return null;\n      }\n\n    case '0x':  //  \"hex\"\n      if (regex['ux'].test(str)) {\n        return { aura: 'ux', atom: BigInt(str.replaceAll('.', '')) };\n      } else {\n        return null;\n      }\n\n    case '0v':  //  \"viz\"\n      if (regex['uv'].test(str)) {\n        return { aura: 'uv', atom: slurp(5, UV_ALPHABET, str.slice(2)) };\n      } else {\n        return null;\n      }\n\n    case '0w':  //  \"wiz\"\n      if (regex['uw'].test(str)) {\n        return { aura: 'uw', atom: slurp(6, UW_ALPHABET, str.slice(2)) };\n      } else {\n        return null;\n      }\n\n    default:  //  \"dem\"\n      if (regex['ud'].test(str)) {\n        return { aura: 'ud', atom: BigInt(str.replaceAll('.', '')) }\n      } else {\n        return null;\n      }\n  }\n}\n\n//  decodeString(): decode string from @ta-safe format\n//\n//    using logic from +woad.\n//    for example, '~.some.~43.hars~21.' becomes 'some Chars!'\n//    assumes\n//\nexport function decodeString(str: string): string {\n  let out = '';\n  let i = 0;\n  while (i < str.length) {\n    switch (str[i]) {\n      case '.':\n        out = out + ' ';\n        i++; continue;\n      case '~':\n        switch (str[++i]) {\n          case '~':\n            out = out + '~';\n            i++; continue;\n          case '.':\n            out = out + '.';\n            i++; continue;\n          default:\n            let char: number = 0;\n            do {\n              char = (char << 4) | Number.parseInt(str[i++], 16);\n            } while (str[i] !== '.')\n            out = out + String.fromCodePoint(char);\n            i++; continue;\n        }\n      default:\n        out = out + str[i++];\n        continue;\n    }\n  }\n  return out;\n}\n\nfunction stringToCord(str: string): bigint {\n  return bytesToBigint(new TextEncoder().encode(str));\n}\n\nconst UW_ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-~';\nconst UV_ALPHABET = '0123456789abcdefghijklmnopqrstuv';\nfunction slurp(bits: number, alphabet: string, str: string): bigint {\n  let out = 0n;\n  const bbits = BigInt(bits);\n  while (str !== '') {\n    if (str[0] !== '.') {\n      out = (out << bbits) + BigInt(alphabet.indexOf(str[0]));\n    }\n    str = str.slice(1);\n  }\n  return out;\n}\n\n//REVIEW  should the reversal happen here or at callsites? depends on what endianness is idiomatic to js?\nfunction bytesToBigint(bytes: Uint8Array): bigint {\n  if (bytes.length === 0) return 0n;\n  //  if we have node's Buffer available, use it, it's wicked fast.\n  //  otherwise, constructing the hex string \"by hand\" and instantiating\n  //  a bigint from that is the fastest thing we can do.\n  //\n  if (typeof Buffer !== 'undefined')\n    return BigInt('0x' + Buffer.from(bytes.reverse()).toString('hex'));\n  let byt: number,\n    parts: string[] = [];\n  for (var i = bytes.length - 1; i >= 0; --i) {\n    byt = bytes[i];\n    parts.push(byt < 16 ? \"0\" + byt.toString(16) : byt.toString(16));\n  }\n  const num = BigInt('0x' + parts.join(''));\n  return num;\n}\n","//  render: serialize into atom literal strings\n//\n//    atom literal rendering from hoon 137 (and earlier).\n//    stdlib arm names are included for ease of cross-referencing.\n//\n//TODO  unsupported auras: @uc\n\nimport { aura, coin } from './types';\n\nimport { renderDa, renderDr } from './d';\nimport { renderP } from './p';\nimport { renderQ } from './q';\nimport { renderR } from './r';\n\n//  render(): scot()\n//  scot(): render atom as specific aura\n//\nexport const render = scot;\nexport default render;\nexport function scot(aura: aura, atom: bigint): string {\n  return rend({ type: 'dime', aura, atom });\n}\n\n//  rend(): render coin into string\n//\nexport function rend(coin: coin): string {\n  switch (coin.type) {\n    case 'blob':\n      return '~0' + coin.jam.toString(32);\n\n    case 'many':\n      return '.' + coin.list.reduce((acc: string, item: coin) => {\n        return acc + '_' + wack(rend(item));\n      }, '') + '__';\n\n    case 'dime':\n      switch(coin.aura[0]) {\n        case 'c':\n          //  this short-circuits the (wood (tuft atom)) calls that\n          //  hoon.hoon does, leaning on wood only for ascii characters,\n          //  and going straight to encoded representation for anything else.\n          //  (otherwise we'd need to stringify the utf-32 bytes, ouch.)\n          if (coin.atom < 0x7fn)\n            return '~-' + encodeString(String.fromCharCode(Number(coin.atom)));\n          else\n            return '~-~' + coin.atom.toString(16) + '.';\n        case 'd':\n          switch(coin.aura[1]) {\n            case 'a':\n              return renderDa(coin.atom);\n            case 'r':\n              return renderDr(coin.atom);\n            default:\n              return zco(coin.atom);\n          }\n        case 'f':\n          switch(coin.atom) {\n            case 0n: return '.y';\n            case 1n: return '.n';\n            default: return zco(coin.atom);\n          }\n        case 'n':\n          return '~';\n        case 'i':\n          switch(coin.aura[1]) {\n            case 'f': return '.' + spite(coin.atom, 1, 4, 10);\n            case 's': return '.' + spite(coin.atom, 2, 8, 16);\n            default: return zco(coin.atom);\n          }\n        case 'p':\n          return renderP(coin.atom);\n        case 'q':\n          return renderQ(coin.atom);\n        case 'r':\n          switch(coin.aura[1]) {\n            case 'd': return renderR('d', coin.atom);\n            case 'h': return renderR('h', coin.atom);\n            case 'q': return renderR('q', coin.atom);\n            case 's': return renderR('s', coin.atom);\n            default: return zco(coin.atom);\n          }\n        case 'u':\n          switch(coin.aura[1]) {\n            case 'c': throw new Error('aura-js: @uc rendering unsupported'); //TODO;\n            case 'b': return '0b' + split(coin.atom.toString(2), 4);\n            case 'i': return '0i' + dco(1, coin.atom);\n            case 'x': return '0x' + split(coin.atom.toString(16), 4);\n            case 'v': return '0v' + split(coin.atom.toString(32), 5);\n            case 'w': return '0w' + split(blend(6, UW_ALPHABET, coin.atom), 5);\n            default: return split(coin.atom.toString(10), 3);\n          }\n        case 's':\n          const end = (coin.atom & 1n);\n          coin.atom = end + (coin.atom >> 1n);\n          coin.aura = coin.aura.replace('s', 'u') as aura;\n          return ((end === 0n) ? '--' : '-') + rend(coin);\n        case 't':\n          if (coin.aura[1] === 'a') {\n            if (coin.aura[2] === 's') {\n              return cordToString(coin.atom);\n            } else {\n              return '~.' + cordToString(coin.atom);\n            }\n          } else {\n            return '~~' + encodeString(cordToString(coin.atom));\n          }\n        default:\n          return zco(coin.atom);\n      }\n  }\n}\n\nfunction dco(lent: number, atom: bigint): string {\n  return atom.toString(10).padStart(lent, '0');\n}\n\nfunction xco(lent: number, atom: bigint): string {\n  return atom.toString(16).padStart(lent, '0');\n}\n\nfunction zco(atom: bigint): string {\n  return '0x' + xco(1, atom);\n}\n\nfunction wack(str: string) {\n  return str.replaceAll('~', '~~').replaceAll('_', '~-');\n}\n\n//  encodeString(): encode string into @ta-safe format\n//\n//    using logic from +wood.\n//    for example, 'some Chars!' becomes '~.some.~43.hars~21.'\n//    this is url-safe encoding for arbitrary strings.\n//\nexport function encodeString(string: string) {\n  let out = '';\n  for (let i = 0; i < string.length; i += 1) {\n    const char = string[i];\n    let add = '';\n    switch (char) {\n      case ' ':\n        add = '.';\n        break;\n      case '.':\n        add = '~.';\n        break;\n      case '~':\n        add = '~~';\n        break;\n      default: {\n        const codePoint = string.codePointAt(i);\n        if (!codePoint) break;\n        //  js strings are encoded in UTF-16, so 16 bits per character.\n        //  codePointAt() reads a _codepoint_ at a character index, and may\n        //  consume up to two js string characters to do so, in the case of\n        //  16 bit surrogate pseudo-characters. here we detect that case, so\n        //  we can advance the cursor to skip past the additional character.\n        if (codePoint > 0xffff) i += 1;\n        if (\n          (codePoint >= 97 && codePoint <= 122) || // a-z\n          (codePoint >= 48 && codePoint <= 57) || // 0-9\n          char === '-'\n        ) {\n          add = char;\n        } else {\n          add = `~${codePoint.toString(16)}.`;\n        }\n      }\n    }\n    out += add;\n  }\n  return out;\n}\n\nconst UW_ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-~';\nfunction blend(bits: number, alphabet: string, atom: bigint): string {\n  if (atom === 0n) return alphabet[0];\n  let out = '';\n  const bbits = BigInt(bits);\n  while (atom !== 0n) {\n    out = alphabet[Number(BigInt.asUintN(bits, atom))] + out;\n    atom = atom >> bbits;\n  }\n  return out;\n}\n\nfunction split(str: string, group: number): string {\n  //  insert '.' every $group characters counting from the end,\n  //  while avoiding putting a leading dot at the start\n  return str.replace(new RegExp(`(?=(?:.{${group}})+$)(?!^)`, 'g'), '.');\n}\n\n//  byte-level split()\nfunction spite(atom: bigint, bytes: number, groups: number, base: number = 10): string {\n  let out = '';\n  const size = 8n * BigInt(bytes);\n  const mask = (1n << size) - 1n;\n  while (groups-- > 0) {\n    if (out !== '') out = '.' + out;\n    out = (atom & mask).toString(base) + out;\n    atom = atom >> size;\n  }\n  return out;\n}\n\nfunction cordToString(atom: bigint): string {\n  return new TextDecoder('utf-8').decode(atomToByteArray(atom).reverse());\n};\n\n//NOTE  from nockjs' bigIntToByteArray\n//REVIEW  original produced [0] for 0n... probably not correct in our contexts!\nfunction atomToByteArray(atom: bigint): Uint8Array {\n  if (atom === 0n) return new Uint8Array(0);\n  const hexString = atom.toString(16);\n  const paddedHexString = hexString.length % 2 === 0 ? hexString : '0' + hexString;\n  const arrayLength = paddedHexString.length / 2;\n  const int8Array = new Uint8Array(arrayLength);\n  for (let i = 0; i < paddedHexString.length; i += 2) {\n    const hexSubstring = paddedHexString.slice(i, i + 2);\n    const signedInt = (parseInt(hexSubstring, 16) << 24) >> 24;\n    int8Array[(i / 2)] = signedInt;\n  }\n  return int8Array;\n}\n","//  main\n\nexport * from './types';\nexport { parse, tryParse, valid, slav, slaw, nuck } from './parse';\nexport { render, scot, rend } from './render';  //TODO  expose encodeString() ?\n\n//  atom utils\n\nimport { toUnix, fromUnix, fromSeconds, toSeconds } from './d';\nexport const da = { toUnix, fromUnix };\nexport const dr = { toSeconds, fromSeconds };\n\nimport type * as pt from './p';\nimport { cite, sein, clan, kind, rankToSize, sizeToRank } from './p';\nexport const p = { cite, sein, clan, kind, rankToSize, sizeToRank };\nexport namespace p {\n  export type rank = pt.rank;\n  export type size = pt.size;\n}\n"],"names":["parseDa","x","pos","date","time","ms","split","yer","month","day","slice","at","hour","minute","sec","millis","map","m","BigInt","det","EPOCH","year","cah","isLeapYear","MOY_YO","MOH_YO","d","first","rest","loop","y","yule","second","parseDr","rop","forEach","a","Error","DA_UNIX_EPOCH","DA_SECOND","DAY_YO","HOR_YO","MIT_YO","ERA_YO","CET_YO","rip","fac","muc","length","yell","toString","padStart","match","pop","hor","mit","F","j","arg","muk","syd","key","lo","Number","hi","kee","String","fromCharCode","murmurhash3_32_gc","seed","remainder","bytes","h1","h1b","c1","c2","k1","i","charCodeAt","feis","Fe","r","b","k","f","c","fe","ell","arr","eff","tail","Fen","fen","ahh","ale","ob","fein","pyn","fynd","cry","regexP","parseP","str","syls","patp2syls","syl2bin","idx","addr","reduce","acc","syl","suffixes","indexOf","prefixes","num","renderP","sxz","dyx","Math","ceil","dyy","tsxz","timp","trep","log","pre","suf","clan","who","checkedParseP","rankToSize","rank","test","validSyllables","isValidP","name","replace","every","index","includes","chunk","size","newArray","push","parseR","per","getPrecision","w","p","bitMask","makeNaN","makeInf","sign","int","undefined","fra","expSign","exp","intPart","floatPart","padEnd","precisionBits","exponentBits","floatDits","exceed","console","warn","bias","minExp","maxExp","minUnnormExp","len","bin","Array","denom","lastBit","rounded","result","n","signal","abs","join","construct","makeFloat","parse","l","renderR","t","s","e","dig","edCo","rCo","float","mantissaMask","exponentMask","floatMantissa","floatExponent","mantissa","exponent","mantissaHighBitIdx","unequalMargins","buf","res","hasUnequalMargins","cutoffMode","cutoffNumber","bufferSize","bexponent","scale","scaledValue","scaledMarginLow","scaledMarginHigh","pCurDigit","outBuffer","fill","outExponent","digits","digitExponent","pow10","cutoffExponent","low","high","outputDigit","roundDown","compare","dragon4","deconstruct","bits","integerRegex","RegExp","floatRegex","regex","da","dr","if","is","q","rd","rh","rq","rs","sb","sd","si","sv","sw","sx","ta","tas","ub","ud","ui","uv","uw","ux","slav","aura","out","slaw","tryParse","coin","nuck","type","atom","stringToCord","dim","bisk","value","v","precision","chunks","dec2hex","dec","splat","splitAt","parseQ","parseValidQ","coins","replaceAll","some","list","parseValidP","decodeString","jam","slurp","UV_ALPHABET","UW_ALPHABET","char","parseInt","fromCodePoint","Buffer","from","reverse","byt","parts","bytesToBigint","TextEncoder","encode","alphabet","bbits","render","scot","rend","item","encodeString","era","cet","lep","dis","inner","mot","zis","yall","yore","renderDa","renderDr","zco","spite","hex","lex","chunked","concat","elem","pair","byts","renderQ","asUintN","blend","end","cordToString","lent","xco","string","add","codePoint","codePointAt","group","groups","base","mask","TextDecoder","decode","Uint8Array","hexString","paddedHexString","int8Array","hexSubstring","signedInt","atomToByteArray","toSeconds","fromSeconds","seconds","cite","sein","mir","kind","sizeToRank","toUnix","round","fromUnix","unix","timeSinceEpoch"],"mappings":"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"}