export declare const fragCache: Record<string, (arg: Noun) => Noun>;
declare class Atom {
    readonly number: bigint;
    private _mug;
    deep: boolean;
    static small: Atom[];
    static zero: Atom;
    static one: Atom;
    static two: Atom;
    static three: Atom;
    constructor(number: bigint);
    isAtom(): this is Atom;
    isCell(): this is Cell<Noun, Noun>;
    pretty(out: string[], hasTail?: boolean): void;
    toString(): string;
    equals(o: Noun): boolean;
    loob(): boolean;
    mug(): number;
    calculateMug(): number;
    mugged(): boolean;
    at(a: Atom): Noun;
    bump(): Atom;
    bytes(): number[];
    cap(): Atom;
    mas(): Atom;
    shortCode(): string;
    static cordToString(c: Atom): string;
    static fragmenter(a: Atom): (arg: Noun) => Noun;
    static fromString(str: string, radix?: number): Atom;
    static fromInt(n: number): Atom;
    static fromCord(str: string): Atom;
}
declare class Cell<TH extends Noun, TT extends Noun> {
    readonly head: TH;
    readonly tail: TT;
    deep: boolean;
    private _mug;
    constructor(head: TH, tail: TT, deep?: boolean);
    isAtom(): this is Atom;
    isCell(): this is Cell<TH, TT>;
    pretty(out: string[], hasTail: boolean): void;
    toString(): string;
    mug(): number;
    calculateMug(): number;
    mugged(): boolean;
    equals(o: Noun): boolean;
    bump(): void;
    loob(): boolean;
    at(a: Atom): Noun;
    unify(o: Cell<Noun, Noun>): boolean;
}
type Noun = Atom | Cell<Noun, Noun>;
export declare function isAtom(a: any): a is Atom;
export declare function isCell(a: any): a is Cell<Noun, Noun>;
export declare function isNoun(a: any): a is Noun;
export { Atom, Cell, Noun };
