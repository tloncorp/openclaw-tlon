function bigIntToByteArray(bigInt) {
  const hexString = bigInt.toString(16);
  const paddedHexString = hexString.length % 2 === 0 ? hexString : '0' + hexString;
  const arrayLength = paddedHexString.length / 2;
  const int8Array = new Uint8Array(arrayLength);
  for (let i = 0; i < paddedHexString.length; i += 2) {
    const hexSubstring = paddedHexString.slice(i, i + 2);
    const signedInt = parseInt(hexSubstring, 16) << 24 >> 24;
    int8Array[i / 2] = signedInt;
  }
  return int8Array;
}
//  bit length cache entries
const blcCoeff = [];
const blcBigCoeff = [];
const blc = [];
let blcNext = 0;
function bitLength(bigIntValue) {
  if (bigIntValue === 0n) return 0;
  //  there is no native bigint bitlength measuring support,
  //  so we roll our own. this beats toString-based implementations (and those,
  //  slightly surprisingly, beat manual bitstep loops).
  //  the approach here is to find *an* upper bound quickly through comparisons,
  //  in exponentially escalating steps, and then slowly step down the
  //  comparisons to find the exact result. we get final precision from
  //  Math.clz32. this approach makes measurements on large bignums way faster.
  //  https://stackoverflow.com/a/76616288
  //  find upper bound
  let k = 0;
  while (true) {
    if (blcNext === k) {
      blcCoeff.push(32 << blcNext);
      blcBigCoeff.push(BigInt(blcCoeff[blcNext]));
      blc.push(1n << blcBigCoeff[blcNext]);
      blcNext++;
    }
    if (bigIntValue < blc[k]) break;
    k++;
  }
  //  smallint case
  if (!k) return 32 - Math.clz32(Number(bigIntValue));
  //  determine exact length by bisection
  k--;
  let i = blcCoeff[k];
  let a = bigIntValue >> blcBigCoeff[k];
  while (k--) {
    let b = a >> blcBigCoeff[k];
    if (b) i += blcCoeff[k], a = b;
  }
  return i + 32 - Math.clz32(Number(a));
}
function testBit(bigIntValue, index) {
  return (bigIntValue & BigInt(1) << BigInt(index)) !== BigInt(0);
}
function bigIntFromStringWithRadix(number, radix) {
  //  native constructor is slightly faster
  if (radix === 16) return BigInt('0x' + (number || '0'));
  if (radix === 10) return BigInt(number || '0');
  let result = BigInt(0);
  const base = BigInt(radix);
  const length = number.length;
  for (let i = 0; i < length; i++) {
    const digit = parseInt(number.charAt(i), radix);
    if (isNaN(digit)) {
      throw new Error(`Invalid character for radix ${radix}: '${number.charAt(i)}'`);
    }
    result = result * base + BigInt(digit);
  }
  return result;
}

// modified from source to accept bigint key and have optional key bytelength arg
// see: https://github.com/garycourt/murmurhash-js
//
// Copyright (c) 2011 Gary Court
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
/**
 * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
 *
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 *
 * @param {string} key ASCII only
 * @param {number} seed Positive integer only
 * @return {number} 32-bit positive integer hash
 **/
function murmurhash3_bi(len, key, seed) {
  let remainder, bytes, h1, h1b, c1, c2, k1, i; // c1b, c2b unused
  let yek;
  if (0n === key) {
    yek = new Uint8Array(0);
    len = len || 0;
  } else {
    yek = bigIntToByteArray(key);
    len = len || yek.length;
  }
  if (yek.length < len) {
    const fil = new Uint8Array(len - yek.length);
    const nek = new Uint8Array(yek.length + fil.length);
    nek.set(fil);
    nek.set(yek, fil.length);
    yek = nek;
  } else if (yek.length > len) {
    throw new Error("murmur3 oversized key for length");
  }
  yek.reverse(); //  shenanigans
  remainder = yek.length & 3; // yek.length % 4
  bytes = yek.length - remainder;
  h1 = seed;
  c1 = 0xcc9e2d51;
  c2 = 0x1b873593;
  i = 0;
  while (i < bytes) {
    k1 = yek[i] & 0xff | (yek[++i] & 0xff) << 8 | (yek[++i] & 0xff) << 16 | (yek[++i] & 0xff) << 24;
    ++i;
    k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;
    k1 = k1 << 15 | k1 >>> 17;
    k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;
    h1 ^= k1;
    h1 = h1 << 13 | h1 >>> 19;
    h1b = (h1 & 0xffff) * 5 + (((h1 >>> 16) * 5 & 0xffff) << 16) & 0xffffffff;
    h1 = (h1b & 0xffff) + 0x6b64 + (((h1b >>> 16) + 0xe654 & 0xffff) << 16);
  }
  k1 = 0;
  switch (remainder) {
    case 3:
      k1 ^= (yek[i + 2] & 0xff) << 16;
    case 2:
      k1 ^= (yek[i + 1] & 0xff) << 8;
    case 1:
      k1 ^= yek[i] & 0xff;
      k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;
      k1 = k1 << 15 | k1 >>> 17;
      k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;
      h1 ^= k1;
  }
  h1 ^= yek.length;
  h1 ^= h1 >>> 16;
  h1 = (h1 & 0xffff) * 0x85ebca6b + (((h1 >>> 16) * 0x85ebca6b & 0xffff) << 16) & 0xffffffff;
  h1 ^= h1 >>> 13;
  h1 = (h1 & 0xffff) * 0xc2b2ae35 + (((h1 >>> 16) * 0xc2b2ae35 & 0xffff) << 16) & 0xffffffff;
  h1 ^= h1 >>> 16;
  return h1 >>> 0;
}

// implementation
function dwim$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  const n = args.length === 1 ? args[0] : args;
  if (isNoun(n)) return n;
  if (typeof n === "number") {
    return Atom.fromInt(n);
  } else if (typeof n === "bigint") {
    return new Atom(n);
  } else if (typeof n === "string") {
    return Atom.fromCord(n);
  } else if (Array.isArray(n)) {
    if (n.length < 2) {
      return dwim$1(n[0]);
    }
    const head = dwim$1(n[n.length - 2]);
    const tail = dwim$1(n[n.length - 1]);
    let cel = new Cell(head, tail);
    for (var j = n.length - 3; j >= 0; --j) {
      cel = new Cell(dwim$1(n[j]), cel);
    }
    return cel;
  } else if (n === null) {
    return Atom.zero;
  }
  //  objects, undefined, etc
  console.error("what do you mean??", typeof n, JSON.stringify(n));
  throw new Error('dwim, but meaning unclear');
}
//  structures
function list$1(args) {
  if (args.length === 0) return Atom.zero;
  return dwim$1([...args, Atom.zero]);
}
function set(args) {
  if (args.length === 0) return Atom.zero;
  let set = Atom.zero;
  for (let arg of args) {
    set = putIn(set, dwim$1(arg));
  }
  return set;
}
function map(args) {
  if (args.length === 0) return Atom.zero;
  let map = Atom.zero;
  for (let arg of args) {
    map = putBy(map, dwim$1(arg.key), dwim$1(arg.val));
  }
  return map;
}
const dejs = {
  nounify: dwim$1,
  dwim: dwim$1,
  list: list$1,
  set,
  map
};

function mum(syd, fal, key) {
  let i = 0;
  while (i < 8) {
    const haz = murmurhash3_bi(null, key, syd);
    const ham = haz >>> 31 ^ haz & 0x7fffffff;
    if (0 !== ham) return ham;
    i++;
    syd++;
  }
  return fal;
}
//
//  ordering
//
//  +dor: depth order
function dor(a, b) {
  //  ?:  =(a b)  &
  if (a.equals(b)) return true;
  //  ?.  ?=(@ a)
  if (a.isCell()) {
    //  ?:  ?=(@ b)  |
    if (b.isAtom()) return false;
    //  ?:  =(-.a -.b)
    if (a.head.equals(b.head))
      //  $(a +.a, b +.b)
      return dor(a.tail, b.tail);
    //  $(a -.a, b -.b)
    return dor(a.head, b.head);
  }
  //  ?.  ?=(@ b)  &
  if (b.isCell()) return true;
  //  (lth a b)
  return a < b;
}
//  +gor: mug hash order, collisions fall back to +dor
function gor(a, b) {
  //  =+  [c=(mug a) d=(mug b)]
  const c = a.mug();
  const d = b.mug();
  //  ?:  =(c d)
  if (c === d)
    //  (dor a b)
    return dor(a, b);
  //  (lth c d)
  return c < d;
}
//  +mor: double mug hash order, collisions fall back to +dor
function mor(a, b) {
  //  =+  [c=(mug (mug a)) d=(mug (mug b))]
  const c = Atom.fromInt(a.mug()).mug();
  const d = Atom.fromInt(b.mug()).mug();
  //  ?:  =(c d)
  if (c === d)
    //  (dor a b)
    return dor(a, b);
  //  (lth c d)
  return c < d;
}
//
//  data structures
//
//  isSet: check for set with >0 entries, ?=([* * *])
function isSet(a) {
  return a.isCell() && a.tail.isCell();
}
//  +put:in: set insertion
function putIn(a, b) {
  //  ?~  a
  //    [b ~ ~]
  if (a.equals(Atom.zero)) {
    return dwim$1(b, null, null);
  }
  if (!isSet(a)) {
    throw new Error('malformed set');
  }
  //  ?:  =(b n.a)
  //    a
  if (b.equals(a.head)) {
    return a;
  }
  //  ?:  (gor b n.a)
  if (gor(b, a.head)) {
    //  =+  c=$(a l.a)
    const c = putIn(a.tail.head, b);
    //  ?>  ?=(^ c)
    if (!isSet(c)) {
      throw new Error('implementation error');
    }
    //  ?:  (mor n.a n.c)
    //    a(l c)
    if (mor(a.head, c.head)) {
      return dwim$1(a.head, c, a.tail.tail);
    }
    //  c(r a(l r.c))
    return dwim$1(c.head, c.tail.head, [a.head, c.tail.tail, a.tail.tail]);
  }
  //  =+  c=$(a r.a)
  const c = putIn(a.tail.tail, b);
  //  ?>  ?=(^ c)
  if (!isSet(c)) {
    throw new Error('implementation error');
  }
  //  ?:  (mor n.a n.c)
  //    a(r c)
  if (mor(a.head, c.head)) {
    return dwim$1(a.head, a.tail.head, c);
  }
  //  c(l a(r l.c))
  return dwim$1(c.head, [a.head, a.tail.head, c.tail.head], c.tail.tail);
}
//  isMap: check for map with >0 entries, ?=([[* *] * *])
function isMap(a) {
  return a.isCell() && a.head.isCell() && a.tail.isCell();
}
//  +put:by: map insertion
function putBy(a, b, c) {
  //  ?~  a
  //    [[b c] ~ ~]
  if (a.equals(Atom.zero)) {
    return dwim$1([b, c], null, null);
  }
  if (!isMap(a)) {
    throw new Error('malformed map');
  }
  //  ?:  =(b p.n.a)
  if (b.equals(a.head.head)) {
    //  ?:  =(c q.n.a)
    //    a
    if (c.equals(a.head.tail)) {
      return a;
    }
    //  a(n [b c])
    return dwim$1([b, c], a.tail);
  }
  //  ?:  (gor b p.n.a)
  if (gor(b, a.head.head)) {
    //  =+  d=$(a l.a)
    const d = putBy(a.tail.head, b, c);
    //  ?>  ?=(^ d)
    if (!isMap(d)) {
      throw new Error('implementation error');
    }
    //  ?:  (mor p.n.a p.n.d)
    //    a(l d)
    if (mor(a.head.head, d.head.head)) {
      return dwim$1(a.head, d, a.tail.tail);
    }
    //  d(r a(l r.d))
    return dwim$1(d.head, d.tail.head, [a.head, d.tail.tail, a.tail.tail]);
  }
  //  =+  d=$(a r.a)
  const d = putBy(a.tail.tail, b, c);
  //  ?>  ?=(^ d)
  if (!isMap(d)) {
    throw new Error('implementation error');
  }
  //  ?:  (mor p.n.a p.n.d)
  //    a(r d)
  if (mor(a.head.head, d.head.head)) {
    return dwim$1(a.head, a.tail.head, d);
  }
  //  d(l a(r l.d))
  return dwim$1(d.head, [a.head, a.tail.head, d.tail.head], d.tail.tail);
}

var _Atom;
// Helpers
const fragCache = {
  "0": function (a) {
    throw new Error("Bail");
  },
  "1": function (a) {
    return a;
  }
};
// Classes
class Atom {
  constructor(number) {
    this.number = void 0;
    this._mug = 0;
    this.deep = false;
    this.number = number;
  }
  // common methods with Cell
  isAtom() {
    return true;
  }
  isCell() {
    return false;
  }
  pretty(out, hasTail) {
    if (this.number < 65536n) out.push(this.number.toString(10));else {
      let tap = [],
        isTa = true,
        isTas = true,
        bytes = bigIntToByteArray(this.number);
      for (let i = bytes.length - 1; i >= 0; --i) {
        const c = bytes[i];
        if (isTa && (c < 32 || c > 127)) {
          isTa = false;
          isTas = false;
          break;
        } else if (isTas && !(c > 47 && c < 58 || c > 96 && c < 123 || c === 45)) isTas = false;
        tap.push(String.fromCharCode(c));
      }
      if (isTas) {
        out.push("%");
        out.push.apply(out, tap);
      } else if (isTa) {
        out.push("'");
        out.push.apply(out, tap);
        out.push("'");
      } else {
        out.push("0x");
        out.push(this.number.toString(16));
      }
    }
  }
  toString() {
    const parts = [];
    this.pretty(parts, false);
    return parts.join("");
  }
  equals(o) {
    return o instanceof Atom && o.number === this.number;
  }
  loob() {
    if (Number(this.number) === 0) return true;
    if (Number(this.number) === 1) return false;else throw new Error("Bail");
  }
  mug() {
    if (this._mug === 0) this._mug = this.calculateMug();
    return this._mug;
  }
  calculateMug() {
    return mum(0xcafebabe, 0x7fff, this.number);
  }
  mugged() {
    return this._mug !== 0;
  }
  at(a) {
    return Atom.fragmenter(a)(this);
  }
  // Atom specific methods
  bump() {
    return new Atom(this.number + 1n);
  }
  bytes() {
    const bytes = bigIntToByteArray(this.number);
    const r = [];
    for (var i = bytes.length - 1; i >= 0; --i) {
      r.push(bytes[i] & 0xff);
    }
    return r;
  }
  cap() {
    if (Number(this.number) === 0) throw new Error("Bail");
    if (Number(this.number) === 1) throw new Error("Bail");else return testBit(this.number, bitLength(this.number) - 2) ? new Atom(3n) : new Atom(2n);
  }
  mas() {
    if (Number(this.number) === 0) throw new Error("Bail");
    if (Number(this.number) === 1) throw new Error("Bail");
    if (Number(this.number) === 2) return new Atom(1n);
    if (Number(this.number) === 3) return new Atom(1n);else {
      const n = this.number;
      const l = bitLength(n) - 2;
      const addTop = BigInt(1 << l);
      const mask = BigInt((1 << l) - 1);
      return new Atom(n & mask ^ addTop);
    }
  }
  shortCode() {
    return this.number.toString(36); // can we do more?
  }
  // Class Methods
  static cordToString(c) {
    const bytes = c.bytes(),
      chars = [];
    for (let i = 0; i < bytes.length; ++i) {
      chars.push(String.fromCharCode(bytes[i]));
    }
    return chars.join("");
  }
  // cached tree addressing function constructor
  static fragmenter(a) {
    const s = a.shortCode();
    if (fragCache.hasOwnProperty(s)) {
      return fragCache[s];
    } else {
      for (var parts = ["a"]; !Atom.one.equals(a); a = a.mas()) {
        parts.push(Atom.two.equals(a.cap()) ? "head" : "tail");
      }
      return fragCache[s] = new Function("a", "return " + parts.join(".") + ";");
    }
  }
  // Atom builders
  static fromString(str, radix) {
    if (radix === void 0) {
      radix = 10;
    }
    const num = bigIntFromStringWithRadix(str, radix);
    return new Atom(num);
  }
  static fromInt(n) {
    if (n < 256) return Atom.small[n];else return new Atom(BigInt(n));
  }
  static fromCord(str) {
    if (str.length === 0) return Atom.zero;
    let i,
      j,
      octs = Array(str.length);
    for (i = 0, j = octs.length - 1; i < octs.length; ++i, --j) {
      const charByte = (str.charCodeAt(i) & 0xff).toString(16);
      octs[j] = charByte.length === 1 ? "0" + charByte : charByte;
    }
    if (str.length > 4) return Atom.fromString(octs.join(''), 16);else return new Atom(BigInt(parseInt(octs.join(""), 16)));
  }
}
_Atom = Atom;
Atom.small = /*#__PURE__*/Array.from(Array(256)).map(function (_, i) {
  return new _Atom(BigInt(i));
});
Atom.zero = _Atom.small[0];
Atom.one = _Atom.small[1];
Atom.two = _Atom.small[2];
Atom.three = _Atom.small[3];
class Cell {
  constructor(head, tail, deep) {
    if (deep === void 0) {
      deep = true;
    }
    this.head = void 0;
    this.tail = void 0;
    this.deep = void 0;
    this._mug = 0;
    this.head = head;
    this.tail = tail;
    this.deep = deep;
  }
  // common methods
  isAtom() {
    return false;
  }
  isCell() {
    return true;
  }
  pretty(out, hasTail) {
    if (!hasTail) out.push("[");
    this.head.pretty(out, false);
    out.push(" ");
    this.tail.pretty(out, true);
    if (!hasTail) out.push("]");
  }
  toString() {
    const parts = [];
    this.pretty(parts, false);
    return parts.join("");
  }
  mug() {
    if (this._mug === 0) this._mug = this.calculateMug();
    return this._mug;
  }
  calculateMug() {
    return mum(0xdeadbeef, 0xfffe, BigInt(this.tail.mug()) << 32n | BigInt(this.head.mug()));
  }
  mugged() {
    return this._mug !== 0;
  }
  equals(o) {
    if (o instanceof Cell) return this.unify(o);else return false;
  }
  bump() {
    throw new Error("Bail");
  }
  loob() {
    throw new Error("Bail");
  }
  at(a) {
    return Atom.fragmenter(a)(this);
  }
  // Cell specific
  unify(o) {
    if (this === o) return true;
    if (o.mugged()) {
      if (this.mugged()) {
        if (this.mug() != o.mug()) return false;
      } else return o.unify(this);
    }
    if (this.head.equals(o.head)) {
      // @ts-ignore, we are intentionally de-duplicating
      o.head = this.head;
      if (this.tail.equals(o.tail)) {
        o._mug = this._mug;
        // @ts-ignore, we are intentionally de-duplicating
        o.tail = this.tail;
        return true;
      }
    }
    return false;
  }
}
function isAtom(a) {
  return a instanceof Atom;
}
function isCell(a) {
  return a instanceof Cell;
}
function isNoun(a) {
  return isAtom(a) || isCell(a);
}

const frond = function (opts) {
  return function (noun) {
    if (!(noun instanceof Cell && noun.head instanceof Atom)) {
      throw new Error("frond: noun not cell with tag head");
    }
    const tag = Atom.cordToString(noun.head);
    for (let i = 0; i < opts.length; i++) {
      if (tag === opts[i].tag) {
        return {
          [tag]: opts[i].get(noun.tail)
        };
      }
    }
    throw new Error("frond: unknown tag" + tag);
  };
};
const tuple = function (funs) {
  return function (noun) {
    let i = 0;
    let o = [];
    while (i < funs.length - 1) {
      if (noun.isAtom()) {
        throw new Error("tuple: noun too shallow");
      }
      o.push(funs[i](noun.head));
      noun = noun.tail;
      i++;
    }
    o.push(funs[i](noun));
    return o;
  };
};
const pairs = function (cels) {
  return function (noun) {
    let i = 0;
    let o = {};
    while (i < cels.length - 1) {
      if (!(noun instanceof Cell)) {
        throw new Error("pairs: noun too shallow");
      }
      o[cels[i].nom] = cels[i].get(noun.head);
      noun = noun.tail;
      i++;
    }
    o[cels[i].nom] = cels[i].get(noun);
    return o;
  };
};
const pair = function (na, ga, nb, gb) {
  return pairs([{
    nom: na,
    get: ga
  }, {
    nom: nb,
    get: gb
  }]);
};
const bucwut = function (opts) {
  return function (noun) {
    for (let i = 0; i < opts.length; i++) {
      try {
        const res = opts[i](noun);
        return res;
      } catch (e) {
        continue;
      }
    }
    throw new Error("bucwut: no matches");
  };
};
//  buccen: like frond, but without the wrapper object
const buccen = function (opts) {
  return function (noun) {
    if (!(noun instanceof Cell && noun.head instanceof Atom)) {
      throw new Error("buccen: noun not cell with tag head");
    }
    const tag = Atom.cordToString(noun.head);
    for (let i = 0; i < opts.length; i++) {
      if (tag === opts[i].tag) {
        return opts[i].get(noun.tail);
      }
    }
    throw new Error("buccen: unknown tag: " + tag);
  };
};
//  (list *) -> any[]
const array = function (item) {
  return function (noun) {
    let a = [];
    while (noun instanceof Cell) {
      a.push(item(noun.head));
      noun = noun.tail;
    }
    return a;
  };
};
//  (tree *) -> any[]
const tree = function (item) {
  return function (noun) {
    if (noun instanceof Cell) {
      if (!(noun.tail instanceof Cell)) {
        throw new Error("tree: malformed");
      }
      return [...tree(item)(noun.tail.tail), item(noun.head), ...tree(item)(noun.tail.head)];
    }
    return [];
  };
};
const cord = function (noun) {
  if (!(noun instanceof Atom)) {
    throw new Error(`cord: noun not atom ${noun.toString()}`);
  }
  return Atom.cordToString(noun);
};
const tape = function (noun) {
  return array(n => {
    if (n.isCell()) {
      throw new Error("tape: malformed");
    }
    return Atom.cordToString(n);
  })(noun).join();
};
const numb = function (noun) {
  if (!(noun instanceof Atom)) {
    throw new Error("numb: noun not atom");
  }
  if (bitLength(noun.number) <= 32) {
    return Number(noun.number);
  } else {
    return noun.number.toString();
  }
};
const numb32 = function (noun) {
  if (!(noun instanceof Atom)) {
    throw new Error("numb32: noun not atom");
  }
  if (bitLength(noun.number) > 32) {
    throw new Error("numb32: number too big");
  }
  return Number(noun.number);
};
const numbString = function (noun) {
  if (!(noun instanceof Atom)) {
    throw new Error("numbString: noun not atom");
  }
  return noun.number.toString();
};
const loob = function (noun) {
  return noun.loob();
};
const nill = function (noun) {
  if (!(noun instanceof Atom && noun.number === 0n)) {
    throw new Error("nill: not null");
  }
  return null;
};
const path = /*#__PURE__*/array(cord);
const enjs = {
  frond,
  tuple,
  pairs,
  pair,
  array,
  loob,
  tree,
  cord,
  tape,
  numb,
  numb32,
  numbString,
  path,
  buccen,
  bucwut,
  nill
};

//TODO  could probably increase performance by not converting bigint -> number
// a is native, returns native
function met(a, b) {
  var bits = bitLength(b.number),
    full = bits >>> a,
    part = full << a !== bits;
  return part ? full + 1 : full;
}
function gth(a, b) {
  return a.number > b.number;
}
function lth(a, b) {
  return a.number < b.number;
}
function gte(a, b) {
  return a.number >= b.number;
}
function lte(a, b) {
  return a.number <= b.number;
}
function add(a, b) {
  return new Atom(a.number + b.number);
}
function sub(a, b) {
  var r = a.number - b.number;
  if (r < 0) {
    throw new Error("subtract underflow");
  } else {
    return new Atom(r);
  }
}
function dec(a) {
  return sub(a, Atom.one);
}
function bex(a) {
  const b = 1n << a.number;
  return new Atom(b);
}
function lsh(a, b, c) {
  var bits = Number(b.number << a.number);
  return new Atom(c.number << BigInt(bits));
}
function rsh(a, b, c) {
  var bits = b.number << a.number;
  return new Atom(c.number >> BigInt(bits));
}
// to/from little-endian 32-bit word array, as used in vere
// TODO: efficiency is horrible here, but can be improved using internals
function bytesToWords(bytes) {
  var len = bytes.length,
    trim = len % 4;
  let i, b, w;
  if (trim > 0) {
    len += 4 - trim;
    for (i = 0; i < trim; ++i) {
      bytes.push(0);
    }
  }
  const size = len >> 2;
  const words = new Array(size);
  for (i = 0, b = 0; i < size; ++i) {
    w = bytes[b++] << 0 & 0x000000ff;
    w ^= bytes[b++] << 8 & 0x0000ff00;
    w ^= bytes[b++] << 16 & 0x00ff0000;
    w ^= bytes[b++] << 24 & 0xff000000;
    words[i] = w;
  }
  return words;
}
function wordsToBytes(words) {
  const buf = [];
  let w, i, b;
  for (i = 0, b = 0; i < words.length; ++i) {
    w = words[i];
    buf[b++] = 0xff & (w & 0x000000ff);
    buf[b++] = 0xff & (w & 0x0000ff00) >>> 8;
    buf[b++] = 0xff & (w & 0x00ff0000) >>> 16;
    buf[b++] = 0xff & (w & 0xff000000) >>> 24;
  }
  // or here. one of the 'get rid of extra zeros' functions.
  while (buf[--b] === 0) {
    buf.pop();
  }
  return buf;
}
function bytesToAtom(bytes) {
  let byt,
    parts = [];
  for (var i = bytes.length - 1; i >= 0; --i) {
    byt = bytes[i] & 0xff;
    parts.push(byt < 16 ? "0" + byt.toString(16) : byt.toString(16));
  }
  const num = bigIntFromStringWithRadix(parts.join(""), 16);
  return new Atom(num);
}
function atomToBytes(atom) {
  return atom.bytes();
}
function atomToWords(atom) {
  return bytesToWords(atomToBytes(atom));
}
function wordsToAtom(words) {
  return bytesToAtom(wordsToBytes(words));
}
// 0x3930b13c0dedeccf01 atom
var malt = wordsToAtom;
// XX: INTERNAL
function slaq(bloq, len) {
  return new Array((len << bloq) + 31 >>> 5);
}
// src is atom, all others native
function chop(met, fum, wid, tou, dst, src) {
  var buf = atomToWords(src),
    len = buf.length,
    i,
    j,
    san,
    mek,
    baf,
    bat,
    hut,
    san,
    wuf,
    wut,
    waf,
    raf,
    wat,
    rat,
    hop;
  if (met < 5) {
    san = 1 << met;
    mek = (1 << san) - 1;
    baf = fum << met;
    bat = tou << met;
    for (i = 0; i < wid; ++i) {
      waf = baf >>> 5;
      raf = baf & 31;
      wat = bat >>> 5;
      rat = bat & 31;
      hop = waf >= len ? 0 : buf[waf];
      hop = hop >>> raf & mek;
      dst[wat] ^= hop << rat;
      baf += san;
      bat += san;
    }
  } else {
    hut = met - 5;
    san = 1 << hut;
    for (i = 0; i < wid; ++i) {
      wuf = fum + i << hut;
      wut = tou + i << hut;
      for (j = 0; j < san; ++j) {
        dst[wut + j] ^= wuf + j >= len ? 0 : buf[wuf + j];
      }
    }
  }
}
// bloq, start, length, atom
function cut(a, b, c, d) {
  //  this is the common case for cue operations, important to be fast,
  //  we can just use native operatios for it
  if (a.number === 0n) {
    return new Atom(d.number >> b.number & (1n << c.number) - 1n);
  }
  var ai = Number(a.number),
    bi = Number(b.number),
    ci = Number(c.number);
  var len = met(ai, d);
  if (Atom.zero.equals(c) || bi >= len) {
    return Atom.zero;
  }
  if (bi + ci > len) {
    ci = len - Number(b.number); // doublecheck
  }
  if (0 === bi && ci === len) {
    return d;
  } else {
    var sal = slaq(ai, ci);
    chop(ai, bi, ci, 0, sal, d);
    return malt(sal);
  }
}
const maxCat = /*#__PURE__*/Atom.fromInt(0xffffffff);
const catBits = /*#__PURE__*/Atom.fromInt(32);
function end(a, b, c) {
  if (gth(a, catBits)) {
    throw new Error("Fail");
  } else if (gth(b, maxCat)) {
    return c;
  } else {
    var ai = Number(a.number),
      bi = Number(b.number),
      len = met(ai, c);
    if (0 === bi) {
      return Atom.zero;
    } else if (bi >= len) {
      return c;
    } else {
      var sal = slaq(ai, bi);
      chop(ai, 0, bi, 0, sal, c);
      return malt(sal);
    }
  }
}
function mix(a, b) {
  return new Atom(a.number ^ b.number);
}
// doublecheck everything
function cat(a, b, c) {
  if (gth(a, catBits)) {
    throw new Error("Fail");
  } else {
    var ai = Number(a.number),
      lew = met(ai, b),
      ler = met(ai, c),
      all = lew + ler;
    if (0 === all) {
      return Atom.zero;
    } else {
      const sal = slaq(ai, all);
      chop(ai, 0, lew, 0, sal, b);
      chop(ai, 0, ler, lew, sal, c);
      return malt(sal);
    }
  }
}
function can(a, b) {
  if (gth(a, catBits)) {
    throw new Error("Fail");
  } else {
    let ai = Number(a.number),
      tot = 0,
      cab = b,
      pos,
      i_cab,
      pi_cab,
      qi_cab;
    // measure
    while (true) {
      if (Atom.zero.equals(cab)) break;
      if (cab instanceof Atom) throw new Error("Fail");
      i_cab = cab.head;
      if (i_cab instanceof Atom) throw new Error("Fail");else if (i_cab instanceof Cell) {
        pi_cab = i_cab.head;
        qi_cab = i_cab.tail;
      }
      if (pi_cab instanceof Atom && gth(pi_cab, maxCat)) throw new Error("Fail");
      if (qi_cab instanceof Cell) throw new Error("Fail");
      if (pi_cab instanceof Atom) tot += Number(pi_cab.number);
      if (cab instanceof Cell) cab = cab.tail;
    }
    if (0 === tot) return Atom.zero;
    var sal = slaq(ai, tot);
    // chop the list atoms in
    cab = b;
    pos = 0;
    while (!Atom.zero.equals(cab)) {
      if (cab instanceof Cell) i_cab = cab.head;
      if (i_cab instanceof Cell) {
        if (i_cab.head instanceof Atom) pi_cab = Number(i_cab.head.number);
        qi_cab = i_cab.tail;
        chop(ai, 0, pi_cab, pos, sal, qi_cab);
        pos += pi_cab;
        if (cab instanceof Cell) cab = cab.tail;
      }
    }
    return malt(sal);
  }
}
var bits = {
  met,
  cut,
  add,
  sub,
  dec,
  gth,
  lth,
  gte,
  lte,
  bex,
  lsh,
  rsh,
  end,
  mix,
  cat,
  can,
  bytesToWords,
  wordsToBytes,
  bytesToAtom,
  atomToBytes,
  atomToWords,
  wordsToAtom
};

const dwim = dejs.dwim;
const mask = function (face, axis, axes) {
  if (axis === void 0) {
    axis = Atom.one;
  }
  if (axes === void 0) {
    axes = {};
  }
  if (typeof face === 'string') {
    if (face === '') return axes;
    axes[face] = axis;
    return axes;
  } else {
    if (face.length === 0) return axes;
    if (face.length === 1) {
      return mask(face[0], axis, axes);
    } else {
      const left = bits.lsh(Atom.zero, Atom.one, axis);
      axes = mask(face[0], left, axes);
      return mask(face.slice(1), left.bump(), axes);
    }
  }
};
const grab = (axes, noun, face) => {
  return noun.at(axes[face]);
};
const experimental = {
  mask,
  grab
};

function flop(a) {
  var b = Atom.zero;
  while (true) {
    if (Atom.zero.equals(a)) {
      return b;
    } else if (a instanceof Atom) {
      throw new Error("Bail");
    } else {
      b = new Cell(a.head, b);
      a = a.tail;
    }
  }
}
function forEach(n, f) {
  while (true) {
    if (Atom.zero.equals(n)) {
      return;
    } else if (n instanceof Atom) {
      throw new Error("Bail");
    } else {
      f(n.head);
      n = n.tail;
    }
  }
}
var list = {
  flop,
  forEach
};

class Slot {}
class Node extends Slot {
  constructor() {
    super();
    this.slots = void 0;
    this.slots = Array(32);
  }
  insert(key, val, lef, rem) {
    lef -= 5;
    const inx = rem >>> lef;
    rem &= (1 << lef) - 1;
    this.slots[inx] = undefined === this.slots[inx] ? new Single(key, val) : this.slots[inx].insert(key, val, lef, rem);
    return this;
  }
  get(key, lef, rem) {
    lef -= 5;
    const inx = rem >>> lef;
    rem &= (1 << lef) - 1;
    const sot = this.slots[inx];
    return undefined === sot ? undefined : sot.get(key, lef, rem);
  }
}
class Bucket extends Slot {
  constructor() {
    super();
    this.singles = void 0;
    this.singles = [];
  }
  insert(key, val, lef, rem) {
    const a = this.singles;
    for (var i = 0; i < a.length; ++i) {
      const s = a[i];
      if (s.key.equals(key)) {
        s.val = val;
        return this;
      }
    }
    a.push(new Single(key, val));
    return this;
  }
  get(key) {
    const a = this.singles;
    for (var i = 0; i < a.length; ++i) {
      const s = a[i];
      if (s.key.equals(key)) {
        return s.val;
      }
    }
  }
}
class Single extends Slot {
  constructor(key, val) {
    super();
    this.key = void 0;
    this.val = void 0;
    this.key = key;
    this.val = val;
  }
  insert(key, val, lef, rem) {
    if (this.key.equals(key)) {
      this.val = val;
      return this;
    } else {
      const rom = this.key.mug() & (1 << lef) - 1;
      const n = lef > 0 ? new Node() : new Bucket();
      n.insert(this.key, this.val, lef, rom);
      n.insert(key, val, lef, rem);
      return n;
    }
  }
  get(key) {
    if (this.key.equals(key)) return this.val;
  }
}
class NounMap {
  constructor() {
    this.slots = void 0;
    this.slots = Array(64);
  }
  insert(key, val) {
    const m = key.mug();
    const inx = m >>> 25;
    const sot = this.slots;
    if (sot[inx] === undefined) sot[inx] = new Single(key, val);else {
      var rem = m & (1 << 25) - 1;
      sot[inx] = sot[inx].insert(key, val, 25, rem);
    }
  }
  get(key) {
    const m = key.mug();
    const inx = m >>> 25;
    const sot = this.slots[inx];
    if (undefined === sot) {
      return undefined;
    } else {
      var rem = m & (1 << 25) - 1;
      return sot.get(key, 25, rem);
    }
  }
}

function bytesToBigint(bytes) {
  if (bytes.length === 1) return BigInt(bytes[0]);
  let byt,
    parts = [];
  for (var i = bytes.length - 1; i >= 0; --i) {
    byt = bytes[i] & 0xff;
    parts.push(byt.toString(16).padStart(2, '0'));
  }
  const num = bigIntFromStringWithRadix(parts.join(""), 16);
  return num;
}
function bigintToDataView(a) {
  return new DataView(new Uint8Array(bigIntToByteArray(a).reverse()).buffer);
}
//  cue
//NOTE  we operate primarily on a DataView (backed by a byte buffer), because
//      that's way faster for big jams than the naive bigint bits operations.
function bi_cut(b, c, d) {
  return dv_cut(Number(b), Number(c), bigintToDataView(d));
}
function dv_bit(b, d) {
  const byte = Math.floor(b / 8);
  return d.getUint8(byte) >> b % 8 & 1;
}
function dv_bitLength(d) {
  const l = d.byteLength - 1;
  if (l > 2 ** 49) throw new Error('bail: oversized byte buffer'); //REVIEW
  return l * 8 + d.getUint8(l).toString(2).length;
}
function dv_cut(b, c, d) {
  if (c === 1) return dv_bit(b, d) ? 1n : 0n;
  const offset = b % 8;
  if (offset === 0) return dv_cut_at_bytes(b, c, d); //TODO  might not matter
  const out = [];
  let curByte = Math.floor(b / 8);
  //  for reading whole bytes, read from both left and right according to offset
  const bitsFromOne = 8 - offset;
  const bitsFromTwo = offset;
  const twoMask = 0xff >> 8 - bitsFromTwo;
  while (c >= 8) {
    const one = d.getUint8(curByte);
    const two = d.getUint8(curByte + 1);
    const left = (two & twoMask) << bitsFromOne;
    const right = one >> bitsFromTwo;
    out.push(left | right);
    curByte++;
    c -= 8;
  }
  //  for the last <8 bits, read them carefully
  if (c > 0n) {
    const bitsFromOne = Math.min(c, 8 - offset);
    const bitsFromTwo = c - bitsFromOne;
    const oneMask = 0xff >> 8 - bitsFromOne << offset;
    const twoMask = 0xff >> 8 - bitsFromTwo;
    const one = d.getUint8(curByte);
    const two = curByte + 1 >= d.byteLength ? 0 : d.getUint8(curByte + 1);
    const left = bitsFromTwo === 0 ? 0 : (two & twoMask) << bitsFromOne;
    const right = (one & oneMask) >> offset;
    out.push(left | right);
  }
  return bytesToBigint(out);
}
function dv_cut_at_bytes(b, c, d) {
  if (b % 8 !== 0) throw new Error('non-byte-aligned read ' + b);
  let curByte = Math.floor(b / 8);
  const out = [];
  //  we can just grab bytes directly
  while (c >= 8) {
    out.push(d.getUint8(curByte));
    curByte++;
    c -= 8;
  }
  //  only for the last one may we need to mask out bits beyond read range
  if (c > 0n) {
    out.push(d.getUint8(curByte) & 0xff >> 8 - c);
  }
  return bytesToBigint(out);
}
function rub(a, v, l) {
  var c, d, e, w, x, y, z, p, q, m;
  m = a + l;
  x = a;
  while (0 === dv_bit(x, v)) {
    y = x + 1;
    //  Sanity check: crash if decoding more bits than available
    if (x > m) throw new Error('bail: rubbing past end');
    x = y;
  }
  if (a === x) return {
    head: 1,
    tail: Atom.zero
  };
  c = x - a;
  d = x + 1;
  x = c - 1;
  if (x > 52) throw new Error('bail: rubbing oversized pointer (>52 bits)');
  y = 2 ** x; // bex(x);
  z = Number(dv_cut(d, x, v));
  e = y + z;
  w = c + c;
  y = w + e;
  z = d + x;
  p = w + e;
  q = dv_cut(z, e, v);
  return {
    head: p,
    tail: new Atom(q)
  };
}
function insert(m, k, n) {
  return m[k] = n;
}
function get(m, k) {
  return m[k];
}
function cue_in(m, vv, l, b) {
  let head;
  let tailhead;
  if (0 === dv_bit(b, vv)) {
    const x = 1 + b;
    const c = rub(x, vv, l);
    head = c.head + 1;
    tailhead = c.tail;
    insert(m, b, tailhead);
  } else {
    let b2 = 2 + b;
    let b1 = 1 + b;
    if (0 === dv_bit(b1, vv)) {
      const u = cue_in(m, vv, l, b2);
      const x = u.head + b2;
      const v = cue_in(m, vv, l, x);
      const y = u.head + v.head;
      head = 2 + y;
      tailhead = new Cell(u.tail, v.tail);
      insert(m, b, tailhead);
    } else {
      const d = rub(b2, vv, l);
      const dd = get(m, Number(d.tail.number));
      if (undefined === dd) throw new Error("Bail");
      head = 2 + d.head;
      tailhead = dd;
    }
  }
  return {
    head: head,
    tail: tailhead
  };
}
function cue(a) {
  return cue_bytes(bigintToDataView(a.number));
}
function cue_bytes(v) {
  return cue_in({}, v, dv_bitLength(v), 0).tail;
}
//  jam
function mat(a) {
  if (Atom.zero.equals(a)) {
    return dwim(1, 1);
  } else {
    const b = dwim(bits.met(0, a)),
      c = dwim(bits.met(0, b)),
      u = bits.dec(c),
      v = bits.add(c, c),
      x = bits.end(Atom.zero, u, b),
      w = bits.bex(c),
      y = bits.lsh(Atom.zero, u, a),
      z = bits.mix(x, y),
      p = bits.add(v, b),
      q = bits.cat(Atom.zero, w, z);
    return dwim(p, q);
  }
}
function _jam_in_pair(m, h_a, t_a, b, l) {
  var w = dwim([2, 1], l),
    x = bits.add(Atom.two, b),
    d = _jam_in(m, h_a, x, w),
    y = bits.add(x, d.head),
    e = _jam_in(m, t_a, y, d.tail.head),
    z = bits.add(d.head, e.head);
  return dwim(bits.add(Atom.two, z), e.tail.head, Atom.zero);
}
function _jam_in_ptr(u_c, l) {
  var d = mat(u_c),
    x = bits.lsh(Atom.zero, Atom.two, d.tail),
    y = bits.add(Atom.two, d.head);
  return dwim(y, [[y, bits.mix(Atom.three, x)], l], Atom.zero);
}
function _jam_in_flat(a, l) {
  var d = mat(a),
    x = bits.add(Atom.one, d.head);
  return dwim(x, [[x, bits.lsh(Atom.zero, Atom.one, d.tail)], l], Atom.zero);
}
function _jam_in(m, a, b, l) {
  const c = m.get(a);
  if (undefined == c) {
    m.insert(a, b);
    return a instanceof Cell ? _jam_in_pair(m, a.head, a.tail, b, l) : _jam_in_flat(a, l);
  } else if (a instanceof Atom && bits.met(0, a) <= bits.met(0, c)) {
    return _jam_in_flat(a, l);
  } else {
    return _jam_in_ptr(c, l);
  }
}
function jam(n) {
  const x = _jam_in(new NounMap(), n, Atom.zero, Atom.zero),
    q = list.flop(x.tail.head);
  return bits.can(Atom.zero, q);
}

export { Atom, Cell, bi_cut, bigintToDataView, cue, cue_bytes, dejs, dwim, enjs, experimental, fragCache, isAtom, isCell, isNoun, jam, mat };
//# sourceMappingURL=nockjs.esm.js.map
