{"version":3,"file":"urbit-http-api.min.js","sources":["../src/types.ts","../node_modules/browser-or-node/lib/index.js","../src/fetch-event-source/parse.ts","../src/fetch-event-source/fetch.ts","../src/utils.ts","../src/Urbit.ts"],"sourcesContent":["/**\n * An urbit style path, rendered as a Javascript string\n * @example\n * `\"/updates\"`\n */\nexport type Path = string;\n\n/**\n * @p including leading sig, rendered as a string\n *\n * @example\n * ```typescript\n * \"~sampel-palnet\"\n * ```\n *\n */\nexport type Patp = string;\n\n/**\n * @p not including leading sig, rendered as a string\n *\n * @example\n * ```typescript\n * \"sampel-palnet\"\n * ```\n *\n */\nexport type PatpNoSig = string;\n\n/**\n * The name of a clay mark, as a string\n *\n * @example\n * ```typescript\n * \"graph-update\"\n * ```\n */\nexport type Mark = string;\n\n/**\n * The name of a gall agent, as a string\n *\n * @example\n *\n * ```typescript\n * \"graph-store\"\n * ```\n */\nexport type GallAgent = string;\n\n/**\n * Description of an outgoing poke\n *\n * @typeParam Action - Typescript type of the data being poked\n */\nexport interface Poke<Action> {\n  /**\n   * Ship to poke. If left empty, the api lib will populate it with the ship that it is connected to.\n   *\n   * @remarks\n   *\n   * This should always be the ship that you are connected to\n   *\n   */\n  ship?: PatpNoSig;\n  /**\n   */\n  app: GallAgent;\n  /**\n   * Mark of the cage to be poked\n   *\n   */\n  mark: Mark;\n  /**\n   * Vase of the cage of to be poked, as JSON\n   */\n  json: Action;\n}\n\n/**\n * Description of a scry request\n */\nexport interface Scry {\n  /** {@inheritDoc GallAgent} */\n  app: GallAgent;\n  /** {@inheritDoc Path} */\n  path: Path;\n}\n\n/**\n * Description of a thread request\n *\n * @typeParam Action - Typescript type of the data being poked\n */\nexport interface Thread<Action> {\n  /**\n   * The mark of the input vase\n   */\n  inputMark: Mark;\n  /**\n   * The mark of the output vase\n   */\n  outputMark: Mark;\n  /**\n   * Name of the thread\n   *\n   * @example\n   * ```typescript\n   * \"graph-add-nodes\"\n   * ```\n   */\n  threadName: string;\n  /**\n   * Desk of thread\n   */\n  desk?: string;\n  /**\n   * Data of the input vase\n   */\n  body: Action;\n}\n\nexport type Action = 'poke' | 'subscribe' | 'ack' | 'unsubscribe' | 'delete';\n\nexport interface PokeHandlers {\n  onSuccess?: () => void;\n  onError?: (e: any) => void;\n}\n\nexport type PokeInterface<T> = PokeHandlers & Poke<T>;\n\nexport interface AuthenticationInterface {\n  ship: string;\n  url: string;\n  code: string;\n  verbose?: boolean;\n}\n\n/**\n * Subscription event handlers\n *\n */\nexport interface SubscriptionInterface {\n  /**\n   * Handle negative %watch-ack\n   */\n  err?(error: any, id: string): void;\n  /**\n   * Handle %fact\n   */\n  event?(data: any, mark: string, id: number): void;\n  /**\n   * Handle %kick\n   */\n  quit?(data: any): void;\n}\n\nexport type OnceSubscriptionErr = 'quit' | 'nack' | 'timeout';\n\nexport interface SubscriptionRequestInterface extends SubscriptionInterface {\n  /**\n   * The app to subscribe to\n   * @example\n   * `\"graph-store\"`\n   */\n  app: GallAgent;\n  /**\n   * The path to which to subscribe\n   * @example\n   * `\"/keys\"`\n   */\n  path: Path;\n}\n\nexport interface headers {\n  'Content-Type': string;\n  Cookie?: string;\n}\n\nexport interface CustomEventHandler {\n  (data: any, response: string): void;\n}\n\nexport interface SSEOptions {\n  headers?: {\n    Cookie?: string;\n  };\n  withCredentials?: boolean;\n}\n\nexport interface Message extends Record<string, any> {\n  action: Action;\n  id?: number;\n}\n\nexport class ResumableError extends Error {}\n\nexport class FatalError extends Error {}\n\nexport class ReapError extends Error {}\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* global window self */\n\nvar isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n\n/* eslint-disable no-restricted-globals */\nvar isWebWorker = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope';\n/* eslint-enable no-restricted-globals */\n\nvar isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n\n/**\n * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0\n * @see https://github.com/jsdom/jsdom/issues/1537\n */\n/* eslint-disable no-undef */\nvar isJsDom = function isJsDom() {\n  return typeof window !== 'undefined' && window.name === 'nodejs' || navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom');\n};\n\nexports.isBrowser = isBrowser;\nexports.isWebWorker = isWebWorker;\nexports.isNode = isNode;\nexports.isJsDom = isJsDom;","/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n  /** The event ID to set the EventSource object's last event ID value. */\n  id: string;\n  /** A string identifying the type of event described. */\n  event: string;\n  /** The event data */\n  data: string;\n  /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n  retry?: number;\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(\n  stream: ReadableStream<Uint8Array>,\n  onChunk: (arr: Uint8Array) => void,\n  responseTimeout?: number\n) {\n  const reader = stream.getReader();\n  let result: ReadableStreamReadResult<Uint8Array> = {\n    done: false,\n    value: new Uint8Array(),\n  };\n\n  while (result && !result.done) {\n    result = await Promise.race([\n      reader.read(),\n      new Promise<ReadableStreamReadResult<Uint8Array>>((_, reject) => {\n        setTimeout(\n          () => reject(new Error('getBytes timed out')),\n          responseTimeout\n        );\n      }),\n    ]);\n\n    onChunk(result.value);\n  }\n}\n\nconst enum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58,\n}\n\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(\n  onLine: (line: Uint8Array, fieldLength: number) => void\n) {\n  let buffer: Uint8Array | undefined;\n  let position: number; // current read position\n  let fieldLength: number; // length of the `field` portion of the line\n  let discardTrailingNewline = false;\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array) {\n    if (buffer === undefined) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr);\n    }\n\n    const bufLength = buffer.length;\n    let lineStart = 0; // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === ControlChars.NewLine) {\n          lineStart = ++position; // skip to next char\n        }\n\n        discardTrailingNewline = false;\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1; // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case ControlChars.Colon:\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart;\n            }\n            break;\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          case ControlChars.CarriageReturn:\n            discardTrailingNewline = true;\n          case ControlChars.NewLine:\n            lineEnd = position;\n            break;\n        }\n      }\n\n      if (lineEnd === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next arr and then continue parsing:\n        break;\n      }\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position; // we're now on the next line\n      fieldLength = -1;\n    }\n\n    if (lineStart === bufLength) {\n      buffer = undefined; // we've finished reading it\n    } else if (lineStart !== 0) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\n\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(\n  onMessage?: (msg: EventSourceMessage) => void,\n  onId?: (id: string) => void,\n  onRetry?: (retry: number) => void\n) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(line: Uint8Array, fieldLength: number) {\n    if (line.length === 0) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset =\n        fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n\n      switch (field) {\n        case 'data':\n          // if this message already has data, append the new value to the old.\n          // otherwise, just set to the new value:\n          message.data = message.data ? message.data + '\\n' + value : value; // otherwise,\n          break;\n        case 'event':\n          message.event = value;\n          break;\n        case 'id':\n          onId?.((message.id = value));\n          break;\n        case 'retry':\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry?.((message.retry = retry));\n          }\n          break;\n      }\n    }\n  };\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\n\nfunction newMessage(): EventSourceMessage {\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  return {\n    data: '',\n    event: '',\n    id: '',\n    retry: undefined,\n  };\n}\n","import { FatalError, ReapError } from '../types';\nimport { EventSourceMessage, getBytes, getLines, getMessages } from './parse';\n\nexport const EventStreamContentType = 'text/event-stream';\n\nconst DefaultRetryInterval = 1000;\nconst LastEventId = 'last-event-id';\n\nexport interface FetchEventSourceInit extends RequestInit {\n  /**\n   * The request headers. FetchEventSource only supports the Record<string,string> format.\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * Called when a response is received. Use this to validate that the response\n   * actually matches what you expect (and throw if it doesn't.) If not provided,\n   * will default to a basic validation to ensure the content-type is text/event-stream.\n   */\n  onopen?: (response: Response, reconnection: boolean) => Promise<void>;\n\n  /**\n   * Called when a message is received. NOTE: Unlike the default browser\n   * EventSource.onmessage, this callback is called for _all_ events,\n   * even ones with a custom `event` field.\n   */\n  onmessage?: (ev: EventSourceMessage) => void;\n\n  /**\n   * Called when a response finishes. If you don't expect the server to kill\n   * the connection, you can throw an exception here and retry using onerror.\n   */\n  onclose?: () => void;\n\n  /**\n   * Called when there is any error making the request / processing messages /\n   * handling callbacks etc. Use this to control the retry strategy: if the\n   * error is fatal, rethrow the error inside the callback to stop the entire\n   * operation. Otherwise, you can return an interval (in milliseconds) after\n   * which the request will automatically retry (with the last-event-id).\n   * If this callback is not specified, or it returns undefined, fetchEventSource\n   * will treat every error as retriable and will try again after 1 second.\n   */\n  onerror?: (err: any) => number | null | undefined | void;\n\n  /**\n   * If true, will keep the request open even if the document is hidden.\n   * By default, fetchEventSource will close the request and reopen it\n   * automatically when the document becomes visible again.\n   */\n  openWhenHidden?: boolean;\n\n  /** The Fetch function to use. Defaults to window.fetch */\n  fetch?: typeof fetch;\n\n  /** How many millisedonds to wait for bytes before timing out */\n  responseTimeout?: number;\n}\n\nexport function fetchEventSource(\n  input: RequestInfo,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    responseTimeout,\n    ...rest\n  }: FetchEventSourceInit\n) {\n  return new Promise<void>((resolve, reject) => {\n    // make a copy of the input headers since we may modify it below:\n    const headers = { ...inputHeaders };\n    if (!headers.accept) {\n      headers.accept = EventStreamContentType;\n    }\n\n    let curRequestController: AbortController;\n    function onVisibilityChange() {\n      curRequestController.abort(); // close existing request on every visibility change\n      if (!document.hidden) {\n        create(); // page is now visible again, recreate request.\n      }\n    }\n\n    if (typeof document !== 'undefined' && !openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange);\n    }\n\n    let retryInterval = DefaultRetryInterval;\n    let retryTimer: ReturnType<typeof setTimeout>;\n    function dispose() {\n      if (typeof document !== 'undefined' && !openWhenHidden) {\n        document.removeEventListener('visibilitychange', onVisibilityChange);\n      }\n      clearTimeout(retryTimer);\n      curRequestController.abort();\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose();\n      resolve(); // don't waste time constructing/logging errors\n    });\n\n    const fetchFn = inputFetch ?? fetch;\n    const onopen = inputOnOpen ?? defaultOnOpen;\n    let isReconnect = false;\n    async function create() {\n      curRequestController = new AbortController();\n      try {\n        const response = (await Promise.race([\n          fetchFn(input, {\n            ...rest,\n            headers,\n            signal: curRequestController.signal,\n          }),\n          new Promise((_, reject) => {\n            setTimeout(\n              () => reject(new Error('fetch timed out')),\n              responseTimeout\n            );\n          }),\n        ])) as Response;\n\n        if (response.status === 404) {\n          onerror?.(new ReapError('Channel reaped'));\n          dispose();\n          resolve();\n          return;\n        }\n\n        if (response.status < 200 || response.status >= 300) {\n          throw new Error(`Invalid server response: ${response.status}`);\n        }\n\n        await onopen(response, isReconnect);\n        // reset reconnect status\n        if (isReconnect) {\n          isReconnect = false;\n        }\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              onmessage,\n              (id) => {\n                if (id) {\n                  // store the id and send it back on the next retry:\n                  headers[LastEventId] = id;\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers[LastEventId];\n                }\n              },\n              (retry) => {\n                retryInterval = retry;\n              }\n            )\n          ),\n          responseTimeout\n        );\n\n        onclose?.();\n        dispose();\n        resolve();\n      } catch (err) {\n        if (!curRequestController.signal.aborted) {\n          // if we haven't aborted the request ourselves:\n          try {\n            isReconnect = true;\n            // check if we need to retry:\n            const interval: any = onerror?.(err) ?? retryInterval;\n            clearTimeout(retryTimer);\n            curRequestController.abort();\n            retryTimer = setTimeout(create, interval);\n          } catch (innerErr) {\n            // we should not retry anymore:\n            dispose();\n            reject(innerErr);\n          }\n        }\n      }\n    }\n\n    create();\n  });\n}\n\nfunction defaultOnOpen(response: Response) {\n  const contentType = response.headers.get('content-type');\n  if (!contentType?.startsWith(EventStreamContentType)) {\n    throw new Error(\n      `Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`\n    );\n  }\n}\n","export function camelize(str: string) {\n  return str\n    .replace(/\\s(.)/g, function ($1: string) {\n      return $1.toUpperCase();\n    })\n    .replace(/\\s/g, '')\n    .replace(/^(.)/, function ($1: string) {\n      return $1.toLowerCase();\n    });\n}\n\nexport function uncamelize(str: string, separator = '-') {\n  // Replace all capital letters by separator followed by lowercase one\n  var str = str.replace(/[A-Z]/g, function (letter: string) {\n    return separator + letter.toLowerCase();\n  });\n  return str.replace(new RegExp('^' + separator), '');\n}\n\n/**\n * Returns a hex string of given length.\n *\n * Poached from StackOverflow.\n *\n * @param len Length of hex string to return.\n */\nexport function hexString(len: number): string {\n  const maxlen = 8;\n  const min = Math.pow(16, Math.min(len, maxlen) - 1);\n  const max = Math.pow(16, Math.min(len, maxlen)) - 1;\n  const n = Math.floor(Math.random() * (max - min + 1)) + min;\n  let r = n.toString(16);\n  while (r.length < len) {\n    r = r + hexString(len - maxlen);\n  }\n  return r;\n}\n\n/**\n * Generates a random UID.\n *\n * Copied from https://github.com/urbit/urbit/blob/137e4428f617c13f28ed31e520eff98d251ed3e9/pkg/interface/src/lib/util.js#L3\n */\nexport function uid(): string {\n  let str = '0v';\n  str += Math.ceil(Math.random() * 8) + '.';\n  for (let i = 0; i < 5; i++) {\n    let _str = Math.ceil(Math.random() * 10000000).toString(32);\n    _str = ('00000' + _str).substr(-5, 5);\n    str += _str + '.';\n  }\n  return str.slice(0, -1);\n}\n\nexport default class EventEmitter {\n  private listeners: Record<string, Function[]> = {};\n\n  on(event: string, callback: Function) {\n    if (!this.listeners.hasOwnProperty(event)) {\n      this.listeners[event] = [];\n    }\n\n    this.listeners[event].push(callback);\n\n    return this;\n  }\n\n  emit(event: string, ...data: any): any {\n    if (!this.listeners.hasOwnProperty(event)) {\n      return null;\n    }\n\n    for (let i = 0; i < this.listeners[event].length; i++) {\n      const callback = this.listeners[event][i];\n\n      callback.call(this, ...data);\n    }\n  }\n}\n","import { isBrowser, isNode } from 'browser-or-node';\nimport { UrbitHttpApiEvent, UrbitHttpApiEventType } from './events';\nimport { fetchEventSource, EventSourceMessage } from './fetch-event-source';\n\nimport {\n  Scry,\n  Thread,\n  AuthenticationInterface,\n  PokeInterface,\n  SubscriptionRequestInterface,\n  headers,\n  SSEOptions,\n  PokeHandlers,\n  Message,\n  FatalError,\n  ReapError,\n} from './types';\nimport EventEmitter, { hexString } from './utils';\n\n/**\n * A class for interacting with an urbit ship, given its URL and code\n */\nexport class Urbit {\n  /**\n   * Event emitter for debugging, see events.ts for full list of events\n   */\n  private emitter = new EventEmitter();\n\n  /**\n   * UID will be used for the channel: The current unix time plus a random hex string\n   */\n  private uid: string = `${Math.floor(Date.now() / 1000)}-${hexString(6)}`;\n\n  /**\n   * lastEventId is an auto-updated index of which events have been *sent* over this channel.\n   * lastHeardEventId is the latest event we have heard back about.\n   * lastAcknowledgedEventId is the latest event we have sent an ack for.\n   */\n  private lastEventId: number = 0;\n  private lastHeardEventId: number = -1;\n  private lastAcknowledgedEventId: number = -1;\n\n  /**\n   * SSE Client is null for now; we don't want to start polling until it the channel exists\n   */\n  private sseClientInitialized: boolean = false;\n\n  /**\n   * Cookie gets set when we log in.\n   */\n  cookie?: string | undefined;\n\n  /**\n   * A registry of requestId to successFunc/failureFunc\n   *\n   * These functions are registered during a +poke and are executed\n   * in the onServerEvent()/onServerError() callbacks. Only one of\n   * the functions will be called, and the outstanding poke will be\n   * removed after calling the success or failure function.\n   */\n\n  private outstandingPokes: Map<number, PokeHandlers> = new Map();\n\n  /**\n   * A registry of requestId to subscription functions.\n   *\n   * These functions are registered during a +subscribe and are\n   * executed in the onServerEvent()/onServerError() callbacks. The\n   * event function will be called whenever a new piece of data on this\n   * subscription is available, which may be 0, 1, or many times. The\n   * disconnect function may be called exactly once.\n   */\n  private outstandingSubscriptions: Map<number, SubscriptionRequestInterface> =\n    new Map();\n\n  /**\n   * Our abort controller, used to close the connection\n   */\n  private abort = new AbortController();\n\n  /**\n   * Identity of the ship we're connected to\n   */\n  ship?: string | null;\n\n  /**\n   * Our identity, with which we are authenticated into the ship\n   */\n  our?: string | null;\n\n  /**\n   * If verbose, logs output eagerly.\n   */\n  verbose?: boolean;\n\n  /**\n   * number of consecutive errors in connecting to the eventsource\n   */\n  private errorCount = 0;\n\n  onError?: (error: any) => void = null;\n\n  onRetry?: () => void = null;\n\n  onOpen?: () => void = null;\n\n  onReconnect?: () => void = null;\n\n  /** This is basic interpolation to get the channel URL of an instantiated Urbit connection. */\n  private get channelUrl(): string {\n    return `${this.url}/~/channel/${this.uid}`;\n  }\n\n  private get fetchOptions(): any {\n    const headers: headers = {\n      'Content-Type': 'application/json',\n    };\n    if (!isBrowser) {\n      headers.Cookie = this.cookie;\n    }\n    return {\n      credentials: 'include',\n      accept: '*',\n      headers,\n      signal: this.abort.signal,\n    };\n  }\n\n  /**\n   * Constructs a new Urbit connection.\n   *\n   * @param url  The URL (with protocol and port) of the ship to be accessed. If\n   * the airlock is running in a webpage served by the ship, this should just\n   * be the empty string.\n   * @param code The access code for the ship at that address\n   */\n  constructor(public url: string, public code?: string, public desk?: string) {\n    if (isBrowser) {\n      window.addEventListener('beforeunload', this.delete);\n    }\n    return this;\n  }\n\n  /**\n   * All-in-one hook-me-up.\n   *\n   * Given a ship, url, and code, this returns an airlock connection\n   * that is ready to go. It `|hi`s itself to create the channel,\n   * then opens the channel via EventSource.\n   *\n   */\n  //TODO  rename this to connect() and only do constructor & event source setup.\n  //      that way it can be used with the assumption that you're already\n  //      authenticated.\n  static async authenticate({\n    ship,\n    url,\n    code,\n    verbose = false,\n  }: AuthenticationInterface) {\n    const airlock = new Urbit(\n      url.startsWith('http') ? url : `http://${url}`,\n      code\n    );\n    airlock.verbose = verbose;\n    airlock.ship = ship;\n    await airlock.connect();\n    await airlock.poke({\n      app: 'hood',\n      mark: 'helm-hi',\n      json: 'opening airlock',\n    });\n    await airlock.eventSource();\n    return airlock;\n  }\n\n  private emit<T extends UrbitHttpApiEventType>(\n    event: T,\n    data: UrbitHttpApiEvent[T]\n  ) {\n    if (this.verbose) {\n      this.emitter.emit(event, data);\n    }\n  }\n\n  on<T extends UrbitHttpApiEventType>(\n    event: T,\n    callback: (data: UrbitHttpApiEvent[T]) => void\n  ): void {\n    this.emitter.on(event, callback);\n\n    this.verbose && console.log(event, 'listening active');\n    if (event === 'init') {\n      this.emitter.emit(event, {\n        uid: this.uid,\n        subscriptions: [...this.outstandingSubscriptions.entries()].map(\n          ([k, v]) => ({ id: k, app: v.app, path: v.path })\n        ),\n      });\n    }\n  }\n\n  /**\n   * Gets the name of the ship accessible at this.url and stores it to this.ship\n   *\n   */\n  async getShipName(): Promise<void> {\n    if (this.ship) {\n      return Promise.resolve();\n    }\n\n    const nameResp = await fetch(`${this.url}/~/host`, {\n      method: 'get',\n      credentials: 'include',\n    });\n    const name = await nameResp.text();\n    this.ship = name.substring(1);\n  }\n\n  /**\n   * Gets the name of the ship accessible at this.url and stores it to this.ship\n   *\n   */\n  async getOurName(): Promise<void> {\n    if (this.our) {\n      return Promise.resolve();\n    }\n\n    const nameResp = await fetch(`${this.url}/~/name`, {\n      method: 'get',\n      credentials: 'include',\n    });\n    const name = await nameResp.text();\n    this.our = name.substring(1);\n  }\n\n  /**\n   * Connects to the Urbit ship. Nothing can be done until this is called.\n   * That's why we roll it into this.authenticate\n   * TODO  as of urbit/urbit#6561, this is no longer true, and we are able\n   *       to interact with the ship using a guest identity.\n   */\n  //TODO  rename to authenticate() and call connect() at the end\n  async connect(): Promise<void> {\n    if (this.verbose) {\n      console.log(\n        `password=${this.code} `,\n        isBrowser\n          ? 'Connecting in browser context at ' + `${this.url}/~/login`\n          : 'Connecting from node context'\n      );\n    }\n    return fetch(`${this.url}/~/login`, {\n      method: 'post',\n      body: `password=${this.code}`,\n      credentials: 'include',\n    }).then(async response => {\n      if (this.verbose) {\n        console.log('Received authentication response', response);\n      }\n      if (response.status >= 200 && response.status < 300) {\n        throw new Error('Login failed with status ' + response.status);\n      }\n      const cookie = response.headers.get('set-cookie');\n      if (!this.ship && cookie) {\n        this.ship = new RegExp(/urbauth-~([\\w-]+)/).exec(cookie)[1];\n      }\n      if (!isBrowser) {\n        this.cookie = cookie;\n      }\n      this.getShipName();\n      this.getOurName();\n    });\n  }\n\n  /**\n   * Initializes the SSE pipe for the appropriate channel.\n   */\n  async eventSource(): Promise<void> {\n    if (this.sseClientInitialized) {\n      return Promise.resolve();\n    }\n    if (this.lastEventId === 0) {\n      this.emit('status-update', { status: 'opening' });\n      // Can't receive events until the channel is open,\n      // so poke and open then\n      await this.poke({\n        app: 'hood',\n        mark: 'helm-hi',\n        json: 'Opening API channel',\n      });\n      return;\n    }\n    this.sseClientInitialized = true;\n    return new Promise((resolve, reject) => {\n      const sseOptions: SSEOptions = {\n        headers: {},\n      };\n      if (isBrowser) {\n        sseOptions.withCredentials = true;\n      } else if (isNode) {\n        sseOptions.headers.Cookie = this.cookie;\n      }\n      fetchEventSource(this.channelUrl, {\n        ...this.fetchOptions,\n        openWhenHidden: true,\n        responseTimeout: 25000,\n        onopen: async (response, isReconnect) => {\n          if (this.verbose) {\n            console.log('Opened eventsource', response);\n          }\n          if (isReconnect) {\n            this.onReconnect && this.onReconnect();\n          }\n          if (response.ok) {\n            this.errorCount = 0;\n            this.onOpen && this.onOpen();\n            this.emit('status-update', {\n              status: isReconnect ? 'reconnected' : 'active',\n            });\n            resolve();\n            return; // everything's good\n          } else {\n            const err = new Error('failed to open eventsource');\n            reject(err);\n          }\n        },\n        onmessage: (event: EventSourceMessage) => {\n          if (this.verbose) {\n            console.log('Received SSE: ', event);\n          }\n          if (!event.id) return;\n          const eventId = parseInt(event.id, 10);\n          this.emit('fact', {\n            id: eventId,\n            data: event.data,\n            time: Date.now(),\n          });\n          if (eventId <= this.lastHeardEventId) {\n            if (this.verbose) {\n              console.log('dropping old or out-of-order event', {\n                eventId,\n                lastHeard: this.lastHeardEventId,\n              });\n            }\n            return;\n          }\n          this.lastHeardEventId = eventId;\n          this.emit('id-update', { lastHeard: this.lastHeardEventId });\n          if (eventId - this.lastAcknowledgedEventId > 20) {\n            this.ack(eventId);\n          }\n\n          if (event.data && JSON.parse(event.data)) {\n            const data: any = JSON.parse(event.data);\n\n            if (\n              data.response === 'poke' &&\n              this.outstandingPokes.has(data.id)\n            ) {\n              const funcs = this.outstandingPokes.get(data.id);\n              if (data.hasOwnProperty('ok')) {\n                funcs.onSuccess();\n              } else if (data.hasOwnProperty('err')) {\n                console.error(data.err);\n                funcs.onError(data.err);\n              } else {\n                console.error('Invalid poke response', data);\n              }\n              this.outstandingPokes.delete(data.id);\n            } else if (\n              data.response === 'subscribe' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              if (data.hasOwnProperty('err')) {\n                console.error(data.err);\n                funcs.err(data.err, data.id);\n                this.outstandingSubscriptions.delete(data.id);\n              }\n            } else if (\n              data.response === 'diff' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              try {\n                funcs.event(data.json, data.mark ?? 'json', data.id);\n              } catch (e) {\n                console.error('Failed to call subscription event callback', e);\n              }\n            } else if (\n              data.response === 'quit' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              funcs.quit(data);\n              this.outstandingSubscriptions.delete(data.id);\n              this.emit('subscription', {\n                id: data.id,\n                status: 'close',\n              });\n            } else if (this.verbose) {\n              console.log([...this.outstandingSubscriptions.keys()]);\n              console.log('Unrecognized response', data);\n            }\n          }\n        },\n        onerror: (error) => {\n          this.errorCount++;\n          this.emit('error', { time: Date.now(), msg: JSON.stringify(error) });\n          if (error instanceof ReapError) {\n            this.seamlessReset();\n            return;\n          }\n          if (!(error instanceof FatalError)) {\n            this.emit('status-update', { status: 'reconnecting' });\n            this.onRetry && this.onRetry();\n            return Math.min(5000, Math.pow(2, this.errorCount - 1) * 750);\n          }\n          this.emit('status-update', { status: 'errored' });\n          this.onError && this.onError(error);\n          throw error;\n        },\n        onclose: () => {\n          console.log('e');\n          throw new Error('Ship unexpectedly closed the connection');\n        },\n      });\n    });\n  }\n\n  /**\n   * Reset airlock, abandoning current subscriptions and wiping state\n   *\n   */\n  reset() {\n    if (this.verbose) {\n      console.log('resetting');\n    }\n    this.delete();\n    this.abort.abort();\n    this.abort = new AbortController();\n    this.uid = `${Math.floor(Date.now() / 1000)}-${hexString(6)}`;\n    this.emit('reset', { uid: this.uid });\n    this.lastEventId = 0;\n    this.lastHeardEventId = -1;\n    this.lastAcknowledgedEventId = -1;\n    this.outstandingSubscriptions = new Map();\n    this.outstandingPokes = new Map();\n    this.sseClientInitialized = false;\n  }\n\n  private seamlessReset() {\n    // called if a channel was reaped by %eyre before we reconnected\n    // so we have to make a new channel.\n    this.uid = `${Math.floor(Date.now() / 1000)}-${hexString(6)}`;\n    this.emit('seamless-reset', { uid: this.uid });\n    this.emit('status-update', { status: 'initial' });\n    this.sseClientInitialized = false;\n    this.lastEventId = 0;\n    this.lastHeardEventId = -1;\n    this.lastAcknowledgedEventId = -1;\n    const oldSubs = [...this.outstandingSubscriptions.entries()];\n    this.outstandingSubscriptions = new Map();\n    oldSubs.forEach(([id, sub]) => {\n      sub.quit({\n        id,\n        response: 'quit',\n      });\n      this.emit('subscription', {\n        id,\n        status: 'close',\n      });\n    });\n\n    this.outstandingPokes.forEach((poke, id) => {\n      poke.onError('Channel was reaped');\n    });\n    this.outstandingPokes = new Map();\n  }\n\n  /**\n   * Autoincrements the next event ID for the appropriate channel.\n   */\n  private getEventId(): number {\n    this.lastEventId += 1;\n    this.emit('id-update', { current: this.lastEventId });\n    return this.lastEventId;\n  }\n\n  /**\n   * Acknowledges an event.\n   *\n   * @param eventId The event to acknowledge.\n   */\n  private async ack(eventId: number): Promise<number | void> {\n    this.lastAcknowledgedEventId = eventId;\n    this.emit('id-update', { lastAcknowledged: eventId });\n    const message: Message = {\n      action: 'ack',\n      'event-id': eventId,\n    };\n    await this.sendJSONtoChannel(message);\n    return eventId;\n  }\n\n  private async sendJSONtoChannel(...json: Message[]): Promise<void> {\n    const response = await fetch(this.channelUrl, {\n      ...this.fetchOptions,\n      method: 'PUT',\n      body: JSON.stringify(json),\n    });\n    if (!response.ok) {\n      throw new Error('Failed to PUT channel');\n    }\n    if (!this.sseClientInitialized) {\n      if (this.verbose) {\n        console.log('initializing event source');\n      }\n      await this.eventSource();\n    }\n  }\n\n  /**\n   * Creates a subscription, waits for a fact and then unsubscribes\n   *\n   * @param app Name of gall agent to subscribe to\n   * @param path Path to subscribe to\n   * @param timeout Optional timeout before ending subscription\n   *\n   * @returns The first fact on the subcription\n   */\n  async subscribeOnce<T = any>(app: string, path: string, timeout?: number) {\n    return new Promise<T>(async (resolve, reject) => {\n      let done = false;\n      let id: number | null = null;\n      const quit = () => {\n        if (!done) {\n          reject('quit');\n        }\n      };\n      const event = (e: T, mark: string, id: number) => {\n        if (!done) {\n          resolve(e);\n          this.unsubscribe(id);\n        }\n      };\n      const request = { app, path, event, err: reject, quit };\n\n      id = await this.subscribe(request);\n\n      if (timeout) {\n        setTimeout(() => {\n          if (!done) {\n            done = true;\n            reject('timeout');\n            this.unsubscribe(id);\n          }\n        }, timeout);\n      }\n    });\n  }\n\n  /**\n   * Pokes a ship with data.\n   *\n   * @param app The app to poke\n   * @param mark The mark of the data being sent\n   * @param json The data to send\n   */\n  async poke<T>(params: PokeInterface<T>): Promise<number> {\n    const { app, mark, json, ship, onSuccess, onError } = {\n      onSuccess: () => {},\n      onError: () => {},\n      ship: this.ship,\n      ...params,\n    };\n\n    if (this.lastEventId === 0) {\n      this.emit('status-update', { status: 'opening' });\n    }\n\n    const message: Message = {\n      id: this.getEventId(),\n      action: 'poke',\n      ship,\n      app,\n      mark,\n      json,\n    };\n    this.outstandingPokes.set(message.id, {\n      onSuccess: () => { onSuccess(); },\n      onError: (err) => { onError(err); },\n    });\n    await this.sendJSONtoChannel(message);\n    return message.id;\n  }\n\n  /**\n   * Subscribes to a path on an app on a ship.\n   *\n   *\n   * @param app The app to subsribe to\n   * @param path The path to which to subscribe\n   * @param handlers Handlers to deal with various events of the subscription\n   */\n  async subscribe(params: SubscriptionRequestInterface): Promise<number> {\n    const { app, path, ship, err, event, quit } = {\n      err: () => {},\n      event: () => {},\n      quit: () => {},\n      ship: this.ship,\n      ...params,\n    };\n\n    if (this.lastEventId === 0) {\n      this.emit('status-update', { status: 'opening' });\n    }\n\n    const message: Message = {\n      id: this.getEventId(),\n      action: 'subscribe',\n      ship,\n      app,\n      path,\n    };\n\n    this.outstandingSubscriptions.set(message.id, {\n      app,\n      path,\n      err,\n      event,\n      quit,\n    });\n\n    this.emit('subscription', {\n      id: message.id,\n      app,\n      path,\n      status: 'open',\n    });\n\n    await this.sendJSONtoChannel(message);\n\n    return message.id;\n  }\n\n  /**\n   * Unsubscribes to a given subscription.\n   *\n   * @param subscription\n   */\n  async unsubscribe(subscription: number) {\n    return this.sendJSONtoChannel({\n      id: this.getEventId(),\n      action: 'unsubscribe',\n      subscription,\n    }).then(() => {\n      this.emit('subscription', {\n        id: subscription,\n        status: 'close',\n      });\n      this.outstandingSubscriptions.delete(subscription);\n    });\n  }\n\n  /**\n   * Deletes the connection to a channel.\n   */\n  async delete() {\n    const body = JSON.stringify([\n      {\n        id: this.getEventId(),\n        action: 'delete',\n      },\n    ]);\n    if (isBrowser) {\n      navigator.sendBeacon(this.channelUrl, body);\n    } else {\n      const response = await fetch(this.channelUrl, {\n        ...this.fetchOptions,\n        method: 'POST',\n        body: body,\n      });\n      if (!response.ok) {\n        throw new Error('Failed to DELETE channel in node context');\n      }\n    }\n  }\n\n  /**\n   * Scry into an gall agent at a path\n   *\n   * @typeParam T - Type of the scry result\n   *\n   * @remarks\n   *\n   * Equivalent to\n   * ```hoon\n   * .^(T %gx /(scot %p our)/[app]/(scot %da now)/[path]/json)\n   * ```\n   * The returned cage must have a conversion to JSON for the scry to succeed\n   *\n   * @param params The scry request\n   * @returns The scry result\n   */\n  async scry<T = any>(params: Scry): Promise<T> {\n    const { app, path } = params;\n    const response = await fetch(\n      `${this.url}/~/scry/${app}${path}.json`,\n      this.fetchOptions\n    );\n\n    if (!response.ok) {\n      return Promise.reject(response);\n    }\n\n    return await response.json();\n  }\n\n  /**\n   * Run a thread\n   *\n   *\n   * @param inputMark   The mark of the data being sent\n   * @param outputMark  The mark of the data being returned\n   * @param threadName  The thread to run\n   * @param body        The data to send to the thread\n   * @returns  The return value of the thread\n   */\n  async thread<R, T = any>(params: Thread<T>): Promise<R> {\n    const {\n      inputMark,\n      outputMark,\n      threadName,\n      body,\n      desk = this.desk,\n    } = params;\n    if (!desk) {\n      throw new Error('Must supply desk to run thread from');\n    }\n    const res = await fetch(\n      `${this.url}/spider/${desk}/${inputMark}/${threadName}/${outputMark}.json`,\n      {\n        ...this.fetchOptions,\n        method: 'POST',\n        body: JSON.stringify(body),\n      }\n    );\n\n    return res.json();\n  }\n\n  /**\n   * Utility function to connect to a ship that has its *.arvo.network domain configured.\n   *\n   * @param name Name of the ship e.g. zod\n   * @param code Code to log in\n   */\n  static async onArvoNetwork(ship: string, code: string): Promise<Urbit> {\n    const url = `https://${ship}.arvo.network`;\n    return await Urbit.authenticate({ ship, url, code });\n  }\n}\n\nexport default Urbit;\n"],"names":["ResumableError","Error","FatalError","ReapError","Object","defineProperty","lib","value","_typeof","Symbol","iterator","obj","constructor","prototype","isBrowser","window","document","isWebWorker","self","name","isNode","process","versions","node","isBrowser_1","isNode_1","getLines","onLine","buffer","position","fieldLength","discardTrailingNewline","arr","undefined","a","b","res","Uint8Array","length","set","concat","bufLength","lineStart","lineEnd","subarray","isJsDom","navigator","userAgent","includes","EventStreamContentType","DefaultRetryInterval","LastEventId","fetchEventSource","input","signal","inputSignal","headers","inputHeaders","onopen","inputOnOpen","onmessage","onclose","onerror","openWhenHidden","fetch","inputFetch","responseTimeout","rest","Promise","resolve","reject","curRequestController","onVisibilityChange","abort","hidden","create","accept","addEventListener","retryTimer","retryInterval","dispose","removeEventListener","clearTimeout","fetchFn","defaultOnOpen","isReconnect","async","AbortController","response","race","_","setTimeout","status","stream","onChunk","reader","getReader","result","done","read","getBytes","body","onMessage","onId","onRetry","message","data","event","id","retry","decoder","TextDecoder","line","field","decode","valueOffset","parseInt","isNaN","getMessages","err","aborted","interval","innerErr","contentType","get","startsWith","hexString","len","min","Math","pow","max","r","floor","random","toString","EventEmitter","listeners","on","callback","this","hasOwnProperty","push","emit","i","call","Urbit","url","code","desk","emitter","uid","Date","now","lastEventId","lastHeardEventId","lastAcknowledgedEventId","sseClientInitialized","cookie","outstandingPokes","Map","outstandingSubscriptions","ship","our","verbose","errorCount","onError","onOpen","onReconnect","channelUrl","fetchOptions","Cookie","credentials","delete","static","airlock","connect","poke","app","mark","json","eventSource","console","log","subscriptions","entries","map","k","v","path","nameResp","method","text","substring","then","RegExp","exec","getShipName","getOurName","ok","eventId","time","lastHeard","ack","JSON","parse","has","funcs","onSuccess","error","e","quit","keys","msg","stringify","seamlessReset","reset","oldSubs","forEach","sub","getEventId","current","lastAcknowledged","action","sendJSONtoChannel","timeout","request","unsubscribe","subscribe","params","subscription","sendBeacon","inputMark","outputMark","threadName","authenticate"],"mappings":"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"}