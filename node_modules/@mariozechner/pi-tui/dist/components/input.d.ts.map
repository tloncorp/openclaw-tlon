{"version":3,"file":"input.d.ts","sourceRoot":"","sources":["../../src/components/input.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,SAAS,EAAiB,KAAK,SAAS,EAAE,MAAM,WAAW,CAAC;AAK1E;;GAEG;AACH,qBAAa,KAAM,YAAW,SAAS,EAAE,SAAS;IACjD,OAAO,CAAC,KAAK,CAAc;IAC3B,OAAO,CAAC,MAAM,CAAa;IACpB,QAAQ,CAAC,EAAE,CAAC,KAAK,EAAE,MAAM,KAAK,IAAI,CAAC;IACnC,QAAQ,CAAC,EAAE,MAAM,IAAI,CAAC;IAE7B,0DAA0D;IAC1D,OAAO,EAAE,OAAO,CAAS;IAGzB,OAAO,CAAC,WAAW,CAAc;IACjC,OAAO,CAAC,SAAS,CAAkB;IAEnC,QAAQ,IAAI,MAAM,CAEjB;IAED,QAAQ,CAAC,KAAK,EAAE,MAAM,GAAG,IAAI,CAG5B;IAED,WAAW,CAAC,IAAI,EAAE,MAAM,GAAG,IAAI,CA+I9B;IAED,OAAO,CAAC,mBAAmB;IAc3B,OAAO,CAAC,iBAAiB;IAiCzB,OAAO,CAAC,gBAAgB;IAkCxB,OAAO,CAAC,WAAW;IASnB,UAAU,IAAI,IAAI,CAEjB;IAED,MAAM,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,EAAE,CAwD9B;CACD","sourcesContent":["import { getEditorKeybindings } from \"../keybindings.js\";\nimport { type Component, CURSOR_MARKER, type Focusable } from \"../tui.js\";\nimport { getSegmenter, isPunctuationChar, isWhitespaceChar, visibleWidth } from \"../utils.js\";\n\nconst segmenter = getSegmenter();\n\n/**\n * Input component - single-line text input with horizontal scrolling\n */\nexport class Input implements Component, Focusable {\n\tprivate value: string = \"\";\n\tprivate cursor: number = 0; // Cursor position in the value\n\tpublic onSubmit?: (value: string) => void;\n\tpublic onEscape?: () => void;\n\n\t/** Focusable interface - set by TUI when focus changes */\n\tfocused: boolean = false;\n\n\t// Bracketed paste mode buffering\n\tprivate pasteBuffer: string = \"\";\n\tprivate isInPaste: boolean = false;\n\n\tgetValue(): string {\n\t\treturn this.value;\n\t}\n\n\tsetValue(value: string): void {\n\t\tthis.value = value;\n\t\tthis.cursor = Math.min(this.cursor, value.length);\n\t}\n\n\thandleInput(data: string): void {\n\t\t// Handle bracketed paste mode\n\t\t// Start of paste: \\x1b[200~\n\t\t// End of paste: \\x1b[201~\n\n\t\t// Check if we're starting a bracketed paste\n\t\tif (data.includes(\"\\x1b[200~\")) {\n\t\t\tthis.isInPaste = true;\n\t\t\tthis.pasteBuffer = \"\";\n\t\t\tdata = data.replace(\"\\x1b[200~\", \"\");\n\t\t}\n\n\t\t// If we're in a paste, buffer the data\n\t\tif (this.isInPaste) {\n\t\t\t// Check if this chunk contains the end marker\n\t\t\tthis.pasteBuffer += data;\n\n\t\t\tconst endIndex = this.pasteBuffer.indexOf(\"\\x1b[201~\");\n\t\t\tif (endIndex !== -1) {\n\t\t\t\t// Extract the pasted content\n\t\t\t\tconst pasteContent = this.pasteBuffer.substring(0, endIndex);\n\n\t\t\t\t// Process the complete paste\n\t\t\t\tthis.handlePaste(pasteContent);\n\n\t\t\t\t// Reset paste state\n\t\t\t\tthis.isInPaste = false;\n\n\t\t\t\t// Handle any remaining input after the paste marker\n\t\t\t\tconst remaining = this.pasteBuffer.substring(endIndex + 6); // 6 = length of \\x1b[201~\n\t\t\t\tthis.pasteBuffer = \"\";\n\t\t\t\tif (remaining) {\n\t\t\t\t\tthis.handleInput(remaining);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconst kb = getEditorKeybindings();\n\n\t\t// Escape/Cancel\n\t\tif (kb.matches(data, \"selectCancel\")) {\n\t\t\tif (this.onEscape) this.onEscape();\n\t\t\treturn;\n\t\t}\n\n\t\t// Submit\n\t\tif (kb.matches(data, \"submit\") || data === \"\\n\") {\n\t\t\tif (this.onSubmit) this.onSubmit(this.value);\n\t\t\treturn;\n\t\t}\n\n\t\t// Deletion\n\t\tif (kb.matches(data, \"deleteCharBackward\")) {\n\t\t\tif (this.cursor > 0) {\n\t\t\t\tconst beforeCursor = this.value.slice(0, this.cursor);\n\t\t\t\tconst graphemes = [...segmenter.segment(beforeCursor)];\n\t\t\t\tconst lastGrapheme = graphemes[graphemes.length - 1];\n\t\t\t\tconst graphemeLength = lastGrapheme ? lastGrapheme.segment.length : 1;\n\t\t\t\tthis.value = this.value.slice(0, this.cursor - graphemeLength) + this.value.slice(this.cursor);\n\t\t\t\tthis.cursor -= graphemeLength;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (kb.matches(data, \"deleteCharForward\")) {\n\t\t\tif (this.cursor < this.value.length) {\n\t\t\t\tconst afterCursor = this.value.slice(this.cursor);\n\t\t\t\tconst graphemes = [...segmenter.segment(afterCursor)];\n\t\t\t\tconst firstGrapheme = graphemes[0];\n\t\t\t\tconst graphemeLength = firstGrapheme ? firstGrapheme.segment.length : 1;\n\t\t\t\tthis.value = this.value.slice(0, this.cursor) + this.value.slice(this.cursor + graphemeLength);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (kb.matches(data, \"deleteWordBackward\")) {\n\t\t\tthis.deleteWordBackwards();\n\t\t\treturn;\n\t\t}\n\n\t\tif (kb.matches(data, \"deleteToLineStart\")) {\n\t\t\tthis.value = this.value.slice(this.cursor);\n\t\t\tthis.cursor = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (kb.matches(data, \"deleteToLineEnd\")) {\n\t\t\tthis.value = this.value.slice(0, this.cursor);\n\t\t\treturn;\n\t\t}\n\n\t\t// Cursor movement\n\t\tif (kb.matches(data, \"cursorLeft\")) {\n\t\t\tif (this.cursor > 0) {\n\t\t\t\tconst beforeCursor = this.value.slice(0, this.cursor);\n\t\t\t\tconst graphemes = [...segmenter.segment(beforeCursor)];\n\t\t\t\tconst lastGrapheme = graphemes[graphemes.length - 1];\n\t\t\t\tthis.cursor -= lastGrapheme ? lastGrapheme.segment.length : 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (kb.matches(data, \"cursorRight\")) {\n\t\t\tif (this.cursor < this.value.length) {\n\t\t\t\tconst afterCursor = this.value.slice(this.cursor);\n\t\t\t\tconst graphemes = [...segmenter.segment(afterCursor)];\n\t\t\t\tconst firstGrapheme = graphemes[0];\n\t\t\t\tthis.cursor += firstGrapheme ? firstGrapheme.segment.length : 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (kb.matches(data, \"cursorLineStart\")) {\n\t\t\tthis.cursor = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (kb.matches(data, \"cursorLineEnd\")) {\n\t\t\tthis.cursor = this.value.length;\n\t\t\treturn;\n\t\t}\n\n\t\tif (kb.matches(data, \"cursorWordLeft\")) {\n\t\t\tthis.moveWordBackwards();\n\t\t\treturn;\n\t\t}\n\n\t\tif (kb.matches(data, \"cursorWordRight\")) {\n\t\t\tthis.moveWordForwards();\n\t\t\treturn;\n\t\t}\n\n\t\t// Regular character input - accept printable characters including Unicode,\n\t\t// but reject control characters (C0: 0x00-0x1F, DEL: 0x7F, C1: 0x80-0x9F)\n\t\tconst hasControlChars = [...data].some((ch) => {\n\t\t\tconst code = ch.charCodeAt(0);\n\t\t\treturn code < 32 || code === 0x7f || (code >= 0x80 && code <= 0x9f);\n\t\t});\n\t\tif (!hasControlChars) {\n\t\t\tthis.value = this.value.slice(0, this.cursor) + data + this.value.slice(this.cursor);\n\t\t\tthis.cursor += data.length;\n\t\t}\n\t}\n\n\tprivate deleteWordBackwards(): void {\n\t\tif (this.cursor === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldCursor = this.cursor;\n\t\tthis.moveWordBackwards();\n\t\tconst deleteFrom = this.cursor;\n\t\tthis.cursor = oldCursor;\n\n\t\tthis.value = this.value.slice(0, deleteFrom) + this.value.slice(this.cursor);\n\t\tthis.cursor = deleteFrom;\n\t}\n\n\tprivate moveWordBackwards(): void {\n\t\tif (this.cursor === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst textBeforeCursor = this.value.slice(0, this.cursor);\n\t\tconst graphemes = [...segmenter.segment(textBeforeCursor)];\n\n\t\t// Skip trailing whitespace\n\t\twhile (graphemes.length > 0 && isWhitespaceChar(graphemes[graphemes.length - 1]?.segment || \"\")) {\n\t\t\tthis.cursor -= graphemes.pop()?.segment.length || 0;\n\t\t}\n\n\t\tif (graphemes.length > 0) {\n\t\t\tconst lastGrapheme = graphemes[graphemes.length - 1]?.segment || \"\";\n\t\t\tif (isPunctuationChar(lastGrapheme)) {\n\t\t\t\t// Skip punctuation run\n\t\t\t\twhile (graphemes.length > 0 && isPunctuationChar(graphemes[graphemes.length - 1]?.segment || \"\")) {\n\t\t\t\t\tthis.cursor -= graphemes.pop()?.segment.length || 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Skip word run\n\t\t\t\twhile (\n\t\t\t\t\tgraphemes.length > 0 &&\n\t\t\t\t\t!isWhitespaceChar(graphemes[graphemes.length - 1]?.segment || \"\") &&\n\t\t\t\t\t!isPunctuationChar(graphemes[graphemes.length - 1]?.segment || \"\")\n\t\t\t\t) {\n\t\t\t\t\tthis.cursor -= graphemes.pop()?.segment.length || 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate moveWordForwards(): void {\n\t\tif (this.cursor >= this.value.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst textAfterCursor = this.value.slice(this.cursor);\n\t\tconst segments = segmenter.segment(textAfterCursor);\n\t\tconst iterator = segments[Symbol.iterator]();\n\t\tlet next = iterator.next();\n\n\t\t// Skip leading whitespace\n\t\twhile (!next.done && isWhitespaceChar(next.value.segment)) {\n\t\t\tthis.cursor += next.value.segment.length;\n\t\t\tnext = iterator.next();\n\t\t}\n\n\t\tif (!next.done) {\n\t\t\tconst firstGrapheme = next.value.segment;\n\t\t\tif (isPunctuationChar(firstGrapheme)) {\n\t\t\t\t// Skip punctuation run\n\t\t\t\twhile (!next.done && isPunctuationChar(next.value.segment)) {\n\t\t\t\t\tthis.cursor += next.value.segment.length;\n\t\t\t\t\tnext = iterator.next();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Skip word run\n\t\t\t\twhile (!next.done && !isWhitespaceChar(next.value.segment) && !isPunctuationChar(next.value.segment)) {\n\t\t\t\t\tthis.cursor += next.value.segment.length;\n\t\t\t\t\tnext = iterator.next();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate handlePaste(pastedText: string): void {\n\t\t// Clean the pasted text - remove newlines and carriage returns\n\t\tconst cleanText = pastedText.replace(/\\r\\n/g, \"\").replace(/\\r/g, \"\").replace(/\\n/g, \"\");\n\n\t\t// Insert at cursor position\n\t\tthis.value = this.value.slice(0, this.cursor) + cleanText + this.value.slice(this.cursor);\n\t\tthis.cursor += cleanText.length;\n\t}\n\n\tinvalidate(): void {\n\t\t// No cached state to invalidate currently\n\t}\n\n\trender(width: number): string[] {\n\t\t// Calculate visible window\n\t\tconst prompt = \"> \";\n\t\tconst availableWidth = width - prompt.length;\n\n\t\tif (availableWidth <= 0) {\n\t\t\treturn [prompt];\n\t\t}\n\n\t\tlet visibleText = \"\";\n\t\tlet cursorDisplay = this.cursor;\n\n\t\tif (this.value.length < availableWidth) {\n\t\t\t// Everything fits (leave room for cursor at end)\n\t\t\tvisibleText = this.value;\n\t\t} else {\n\t\t\t// Need horizontal scrolling\n\t\t\t// Reserve one character for cursor if it's at the end\n\t\t\tconst scrollWidth = this.cursor === this.value.length ? availableWidth - 1 : availableWidth;\n\t\t\tconst halfWidth = Math.floor(scrollWidth / 2);\n\n\t\t\tif (this.cursor < halfWidth) {\n\t\t\t\t// Cursor near start\n\t\t\t\tvisibleText = this.value.slice(0, scrollWidth);\n\t\t\t\tcursorDisplay = this.cursor;\n\t\t\t} else if (this.cursor > this.value.length - halfWidth) {\n\t\t\t\t// Cursor near end\n\t\t\t\tvisibleText = this.value.slice(this.value.length - scrollWidth);\n\t\t\t\tcursorDisplay = scrollWidth - (this.value.length - this.cursor);\n\t\t\t} else {\n\t\t\t\t// Cursor in middle\n\t\t\t\tconst start = this.cursor - halfWidth;\n\t\t\t\tvisibleText = this.value.slice(start, start + scrollWidth);\n\t\t\t\tcursorDisplay = halfWidth;\n\t\t\t}\n\t\t}\n\n\t\t// Build line with fake cursor\n\t\t// Insert cursor character at cursor position\n\t\tconst beforeCursor = visibleText.slice(0, cursorDisplay);\n\t\tconst atCursor = visibleText[cursorDisplay] || \" \"; // Character at cursor, or space if at end\n\t\tconst afterCursor = visibleText.slice(cursorDisplay + 1);\n\n\t\t// Hardware cursor marker (zero-width, emitted before fake cursor for IME positioning)\n\t\tconst marker = this.focused ? CURSOR_MARKER : \"\";\n\n\t\t// Use inverse video to show cursor\n\t\tconst cursorChar = `\\x1b[7m${atCursor}\\x1b[27m`; // ESC[7m = reverse video, ESC[27m = normal\n\t\tconst textWithCursor = beforeCursor + marker + cursorChar + afterCursor;\n\n\t\t// Calculate visual width\n\t\tconst visualLength = visibleWidth(textWithCursor);\n\t\tconst padding = \" \".repeat(Math.max(0, availableWidth - visualLength));\n\t\tconst line = prompt + textWithCursor + padding;\n\n\t\treturn [line];\n\t}\n}\n"]}