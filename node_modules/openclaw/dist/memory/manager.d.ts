import type { OpenClawConfig } from "../config/config.js";
type MemorySource = "memory" | "sessions";
export type MemorySearchResult = {
    path: string;
    startLine: number;
    endLine: number;
    score: number;
    snippet: string;
    source: MemorySource;
};
type MemorySyncProgressUpdate = {
    completed: number;
    total: number;
    label?: string;
};
export declare class MemoryIndexManager {
    private readonly cacheKey;
    private readonly cfg;
    private readonly agentId;
    private readonly workspaceDir;
    private readonly settings;
    private provider;
    private readonly requestedProvider;
    private fallbackFrom?;
    private fallbackReason?;
    private openAi?;
    private gemini?;
    private batch;
    private batchFailureCount;
    private batchFailureLastError?;
    private batchFailureLastProvider?;
    private batchFailureLock;
    private db;
    private readonly sources;
    private providerKey;
    private readonly cache;
    private readonly vector;
    private readonly fts;
    private vectorReady;
    private watcher;
    private watchTimer;
    private sessionWatchTimer;
    private sessionUnsubscribe;
    private intervalTimer;
    private closed;
    private dirty;
    private sessionsDirty;
    private sessionsDirtyFiles;
    private sessionPendingFiles;
    private sessionDeltas;
    private sessionWarm;
    private syncing;
    static get(params: {
        cfg: OpenClawConfig;
        agentId: string;
    }): Promise<MemoryIndexManager | null>;
    private constructor();
    warmSession(sessionKey?: string): Promise<void>;
    search(query: string, opts?: {
        maxResults?: number;
        minScore?: number;
        sessionKey?: string;
    }): Promise<MemorySearchResult[]>;
    private searchVector;
    private buildFtsQuery;
    private searchKeyword;
    private mergeHybridResults;
    sync(params?: {
        reason?: string;
        force?: boolean;
        progress?: (update: MemorySyncProgressUpdate) => void;
    }): Promise<void>;
    readFile(params: {
        relPath: string;
        from?: number;
        lines?: number;
    }): Promise<{
        text: string;
        path: string;
    }>;
    status(): {
        files: number;
        chunks: number;
        dirty: boolean;
        workspaceDir: string;
        dbPath: string;
        provider: string;
        model: string;
        requestedProvider: string;
        sources: MemorySource[];
        extraPaths: string[];
        sourceCounts: Array<{
            source: MemorySource;
            files: number;
            chunks: number;
        }>;
        cache?: {
            enabled: boolean;
            entries?: number;
            maxEntries?: number;
        };
        fts?: {
            enabled: boolean;
            available: boolean;
            error?: string;
        };
        fallback?: {
            from: string;
            reason?: string;
        };
        vector?: {
            enabled: boolean;
            available?: boolean;
            extensionPath?: string;
            loadError?: string;
            dims?: number;
        };
        batch?: {
            enabled: boolean;
            failures: number;
            limit: number;
            wait: boolean;
            concurrency: number;
            pollIntervalMs: number;
            timeoutMs: number;
            lastError?: string;
            lastProvider?: string;
        };
    };
    probeVectorAvailability(): Promise<boolean>;
    probeEmbeddingAvailability(): Promise<{
        ok: boolean;
        error?: string;
    }>;
    close(): Promise<void>;
    private ensureVectorReady;
    private loadVectorExtension;
    private ensureVectorTable;
    private dropVectorTable;
    private buildSourceFilter;
    private openDatabase;
    private openDatabaseAtPath;
    private seedEmbeddingCache;
    private swapIndexFiles;
    private moveIndexFiles;
    private removeIndexFiles;
    private ensureSchema;
    private ensureWatcher;
    private ensureSessionListener;
    private scheduleSessionDirty;
    private processSessionDeltaBatch;
    private updateSessionDelta;
    private countNewlines;
    private resetSessionDelta;
    private isSessionFileForAgent;
    private ensureIntervalSync;
    private scheduleWatchSync;
    private shouldSyncSessions;
    private syncMemoryFiles;
    private syncSessionFiles;
    private createSyncProgress;
    private runSync;
    private shouldFallbackOnError;
    private resolveBatchConfig;
    private activateFallbackProvider;
    private runSafeReindex;
    private resetIndex;
    private readMeta;
    private writeMeta;
    private listSessionFiles;
    private sessionPathForFile;
    private normalizeSessionText;
    private extractSessionText;
    private buildSessionEntry;
    private estimateEmbeddingTokens;
    private buildEmbeddingBatches;
    private loadEmbeddingCache;
    private upsertEmbeddingCache;
    private pruneEmbeddingCacheIfNeeded;
    private embedChunksInBatches;
    private computeProviderKey;
    private embedChunksWithBatch;
    private embedChunksWithOpenAiBatch;
    private embedChunksWithGeminiBatch;
    private embedBatchWithRetry;
    private isRetryableEmbeddingError;
    private resolveEmbeddingTimeout;
    private embedQueryWithTimeout;
    private withTimeout;
    private runWithConcurrency;
    private withBatchFailureLock;
    private resetBatchFailureCount;
    private recordBatchFailure;
    private isBatchTimeoutError;
    private runBatchWithTimeoutRetry;
    private runBatchWithFallback;
    private getIndexConcurrency;
    private indexFile;
}
export {};
