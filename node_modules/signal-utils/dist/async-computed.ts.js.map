{"version":3,"file":"async-computed.ts.js","sources":["../src/async-computed.ts"],"sourcesContent":["import { Signal } from \"signal-polyfill\";\n\nexport type AsyncComputedStatus = \"initial\" | \"pending\" | \"complete\" | \"error\";\n\nexport interface AsyncComputedOptions<T> {\n  /**\n   * The initial value of the AsyncComputed.\n   */\n  initialValue?: T;\n}\n\n/**\n * A signal-like object that represents an asynchronous computation.\n *\n * AsyncComputed takes a compute function that performs an asynchronous\n * computation and runs it inside a computed signal, while tracking the status\n * of the computation, including its most recent completion value and error.\n *\n * Compute functions are run when the `value`, `error`, or `complete` properties\n * are read, or when `get()` or `run()` are called, and are re-run when any\n * signals that they read change.\n *\n * If a new run of the compute function is started before the previous run has\n * completed, the previous run will have its AbortSignal aborted, and the result\n * of the previous run will be ignored.\n */\nexport class AsyncComputed<T> {\n  // Whether we have been notified of a pending update from the watcher. This is\n  // set synchronously when any dependencies of the compute function change.\n  #isNotified = false;\n  #status = new Signal.State<AsyncComputedStatus>(\"initial\");\n\n  /**\n   * The current status of the AsyncComputed, which is one of 'initial',\n   * 'pending', 'complete', or 'error'.\n   *\n   * The status will be 'initial' until the compute function is first run.\n   *\n   * The status will be 'pending' while the compute function is running. If the\n   * status is 'pending', the `value` and `error` properties will be the result\n   * of the previous run of the compute function.\n   *\n   * The status will be 'complete' when the compute function has completed\n   * successfully. If the status is 'complete', the `value` property will be the\n   * result of the previous run of the compute function and the `error` property\n   * will be `undefined`.\n   *\n   * The status will be 'error' when the compute function has completed with an\n   * error. If the status is 'error', the `error` property will be the error\n   * that was thrown by the previous run of the compute function and the `value`\n   * property will be `undefined`.\n   *\n   * This value is read from a signal, so any signals that read it will be\n   * tracked as dependents of it.\n   *\n   * Accessing this property will cause the compute function to run if it hasn't\n   * already.\n   */\n  get status() {\n    this.run();\n    // Unconditionally read the status signal to ensure that any signals that\n    // read it are tracked as dependents.\n    const currentState = this.#status.get();\n    // Read from the non-signal #isNotified field, which can be set by the\n    // watcher synchronously.\n    return this.#isNotified ? \"pending\" : currentState;\n  }\n\n  #value: Signal.State<T | undefined>;\n\n  /**\n   * The last value that the compute function resolved with, or `undefined` if\n   * the last run of the compute function threw an error. If the compute\n   * function has not yet been run `value` will be the value of the\n   * `initialValue` or `undefined`.\n   *\n   * This value is read from a signal, so any signals that read it will be\n   * tracked as dependents of it.\n   *\n   * Accessing this property will cause the compute function to run if it hasn't\n   * already.\n   */\n  get value() {\n    this.run();\n    return this.#value.get();\n  }\n\n  #error = new Signal.State<unknown | undefined>(undefined);\n\n  /**\n   * The last error that the compute function threw, or `undefined` if the last\n   * run of the compute function resolved successfully, or if the compute\n   * function has not yet been run.\n   *\n   * This value is read from a signal, so any signals that read it will be\n   * tracked as dependents of it.\n   *\n   * Accessing this property will cause the compute function to run if it hasn't\n   * already.\n   */\n  get error() {\n    this.run();\n    return this.#error.get();\n  }\n\n  #deferred = new Signal.State<PromiseWithResolvers<T> | undefined>(undefined);\n\n  /**\n   * A promise that resolves when the compute function has completed, or rejects\n   * if the compute function throws an error.\n   *\n   * If a new run of the compute function is started before the previous run has\n   * completed, the promise will resolve with the result of the new run.\n   *\n   * This value is read from a signal, so any signals that read it will be\n   * tracked as dependents of it. The identity of the promise will change if the\n   * compute function is re-run after having completed or errored.\n   *\n   * Accessing this property will cause the compute function to run if it hasn't\n   * already.\n   */\n  get complete(): Promise<T> {\n    this.run();\n    // run() will have created a new deferred if needed.\n    return this.#deferred.get()!.promise;\n  }\n\n  #computed: Signal.Computed<void>;\n\n  #watcher: Signal.subtle.Watcher;\n\n  // A unique ID for the current run. This is used to ensure that runs that have\n  // been preempted by a new run do not update state or resolve the deferred\n  // with the wrong result.\n  #currentRunId = 0;\n\n  #currentAbortController?: AbortController;\n\n  /**\n   * Creates a new AsyncComputed signal.\n   *\n   * @param fn The function that performs the asynchronous computation. Any\n   * signals read synchronously - that is, before the first await - will be\n   * tracked as dependencies of the AsyncComputed, and cause the function to\n   * re-run when they change.\n   *\n   * @param options.initialValue The initial value of the AsyncComputed.\n   */\n  constructor(\n    fn: (abortSignal: AbortSignal) => Promise<T>,\n    options?: AsyncComputedOptions<T>,\n  ) {\n    this.#value = new Signal.State(options?.initialValue);\n    this.#computed = new Signal.Computed(() => {\n      const runId = ++this.#currentRunId;\n      // Untrack reading the status signal to avoid triggering the computed when\n      // the status changes.\n      const status = Signal.subtle.untrack(() => this.#status.get());\n\n      // If we're not already pending, create a new deferred to track the\n      // completion of the run.\n      if (status !== \"pending\") {\n        this.#deferred.set(Promise.withResolvers());\n      }\n      this.#isNotified = false;\n      this.#status.set(\"pending\");\n\n      this.#currentAbortController?.abort();\n      this.#currentAbortController = new AbortController();\n\n      fn(this.#currentAbortController.signal).then(\n        (result) => {\n          // If we've been preempted by a new run, don't update the status or\n          // resolve the deferred.\n          if (runId !== this.#currentRunId) {\n            return;\n          }\n          this.#status.set(\"complete\");\n          this.#value.set(result);\n          this.#error.set(undefined);\n          this.#deferred.get()!.resolve(result);\n        },\n        (error) => {\n          // If we've been preempted by a new run, don't update the status or\n          // resolve the deferred.\n          if (runId !== this.#currentRunId) {\n            return;\n          }\n          this.#status.set(\"error\");\n          this.#error.set(error);\n          this.#value.set(undefined);\n          this.#deferred.get()!.reject(error);\n        },\n      );\n    });\n    this.#watcher = new Signal.subtle.Watcher(async () => {\n      // Set the #isNotified flag synchronously when any dependencies change, so\n      // that it can be read synchronously by the status getter.\n      this.#isNotified = true;\n      this.#watcher.watch();\n    });\n    this.#watcher.watch(this.#computed);\n  }\n\n  /**\n   * Returns the last value that the compute function resolved with, or\n   * the initial value if the compute function has not yet been run.\n   *\n   * @throws The last error that the compute function threw, is the last run of\n   * the compute function threw an error.\n   */\n  get() {\n    const status = this.status;\n    if (\n      status === \"error\" ||\n      (status === \"pending\" && this.error !== undefined)\n    ) {\n      throw this.error;\n    }\n    return this.value;\n  }\n\n  /**\n   * Runs the compute function if it is not already running and its dependencies\n   * have changed.\n   */\n  run() {\n    this.#computed.get();\n  }\n}\n"],"names":["AsyncComputed","Signal","State","status","run","currentState","get","value","undefined","error","complete","promise","constructor","fn","options","initialValue","Computed","runId","subtle","untrack","set","Promise","withResolvers","abort","AbortController","signal","then","result","resolve","reject","Watcher","watch"],"mappings":"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"}