{"version":3,"file":"microtask-effect.ts.js","sources":["../../src/subtle/microtask-effect.ts"],"sourcesContent":["import { Signal } from \"signal-polyfill\";\n\n// NOTE: this implementation *LEAKS*\n//       because there is nothing to unwatch a computed.\n\nlet pending = false;\n\nlet watcher = new Signal.subtle.Watcher(() => {\n  if (!pending) {\n    pending = true;\n    queueMicrotask(() => {\n      pending = false;\n      flushPending();\n    });\n  }\n});\n\nfunction flushPending() {\n  for (const signal of watcher.getPending()) {\n    signal.get();\n  }\n\n  // Keep watching... we don't know when we're allowed to stop watching\n  watcher.watch();\n}\n\n/**\n * ⚠️ WARNING: Nothing unwatches ⚠️\n * This will produce a memory leak.\n */\nexport function effect(cb: () => void) {\n  let c = new Signal.Computed(() => cb());\n\n  watcher.watch(c);\n\n  c.get();\n\n  return () => {\n    watcher.unwatch(c);\n  };\n}\n"],"names":["pending","watcher","Signal","subtle","Watcher","queueMicrotask","flushPending","signal","getPending","get","watch","effect","cb","c","Computed","unwatch"],"mappings":";;AAEA;AACA;;AAEA,IAAIA,OAAO,GAAG,KAAK,CAAA;AAEnB,IAAIC,OAAO,GAAG,IAAIC,MAAM,CAACC,MAAM,CAACC,OAAO,CAAC,MAAM;EAC5C,IAAI,CAACJ,OAAO,EAAE;AACZA,IAAAA,OAAO,GAAG,IAAI,CAAA;AACdK,IAAAA,cAAc,CAAC,MAAM;AACnBL,MAAAA,OAAO,GAAG,KAAK,CAAA;AACfM,MAAAA,YAAY,EAAE,CAAA;AAChB,KAAC,CAAC,CAAA;AACJ,GAAA;AACF,CAAC,CAAC,CAAA;AAEF,SAASA,YAAYA,GAAG;EACtB,KAAK,MAAMC,MAAM,IAAIN,OAAO,CAACO,UAAU,EAAE,EAAE;IACzCD,MAAM,CAACE,GAAG,EAAE,CAAA;AACd,GAAA;;AAEA;EACAR,OAAO,CAACS,KAAK,EAAE,CAAA;AACjB,CAAA;;AAEA;AACA;AACA;AACA;AACO,SAASC,MAAMA,CAACC,EAAc,EAAE;EACrC,IAAIC,CAAC,GAAG,IAAIX,MAAM,CAACY,QAAQ,CAAC,MAAMF,EAAE,EAAE,CAAC,CAAA;AAEvCX,EAAAA,OAAO,CAACS,KAAK,CAACG,CAAC,CAAC,CAAA;EAEhBA,CAAC,CAACJ,GAAG,EAAE,CAAA;AAEP,EAAA,OAAO,MAAM;AACXR,IAAAA,OAAO,CAACc,OAAO,CAACF,CAAC,CAAC,CAAA;GACnB,CAAA;AACH;;;;"}