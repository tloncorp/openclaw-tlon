{"version":3,"file":"util.ts.js","sources":["../../src/-private/util.ts"],"sourcesContent":["import { Signal } from \"signal-polyfill\";\n\n/**\n * equality check here is always false so that we can dirty the storage\n * via setting to _anything_\n *\n *\n * This is for a pattern where we don't *directly* use signals to back the values used in collections\n * so that instanceof checks and getters and other native features \"just work\" without having\n * to do nested proxying.\n *\n * (though, see deep.ts for nested / deep behavior)\n */\nexport const createStorage = (initial = null) =>\n  new Signal.State(initial, { equals: () => false });\n\n/**\n * Just an alias for brevity\n */\nexport type Storage = Signal.State<null>;\nexport type StorageMap<T> = Map<T, Storage>;\nexport type StorageWeakMap<T extends object> = WeakMap<T, Storage>;\n\nconst BOUND_FUNS = new WeakMap<object, Map<KeyType, unknown>>();\n\nexport function fnCacheFor<T extends object = object>(context: T) {\n  let fnCache = BOUND_FUNS.get(context);\n\n  if (!fnCache) {\n    fnCache = new Map();\n    BOUND_FUNS.set(context, fnCache);\n  }\n\n  return fnCache; // as Map<keyof T, T[keyof T]>;\n}\n"],"names":["createStorage","initial","Signal","State","equals","BOUND_FUNS","WeakMap","fnCacheFor","context","fnCache","get","Map","set"],"mappings":";;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACaA,MAAAA,aAAa,GAAGA,CAACC,OAAO,GAAG,IAAI,KAC1C,IAAIC,MAAM,CAACC,KAAK,CAACF,OAAO,EAAE;EAAEG,MAAM,EAAEA,MAAM,KAAA;AAAM,CAAC,EAAC;;AAEpD;AACA;AACA;;AAKA,MAAMC,UAAU,GAAG,IAAIC,OAAO,EAAiC,CAAA;AAExD,SAASC,UAAUA,CAA4BC,OAAU,EAAE;AAChE,EAAA,IAAIC,OAAO,GAAGJ,UAAU,CAACK,GAAG,CAACF,OAAO,CAAC,CAAA;EAErC,IAAI,CAACC,OAAO,EAAE;AACZA,IAAAA,OAAO,GAAG,IAAIE,GAAG,EAAE,CAAA;AACnBN,IAAAA,UAAU,CAACO,GAAG,CAACJ,OAAO,EAAEC,OAAO,CAAC,CAAA;AAClC,GAAA;EAEA,OAAOA,OAAO,CAAC;AACjB;;;;"}