{"version":3,"file":"array-map.ts.js","sources":["../src/array-map.ts"],"sourcesContent":["import { signal } from \"./index.ts\";\n\n/**\n * Public API of the return value of the [[map]] utility.\n */\nexport interface MappedArray<Elements extends readonly unknown[], MappedTo> {\n  /**\n   * Array-index access to specific mapped data.\n   *\n   * If the map function hasn't run yet on the source data, it will be run, and cached\n   * for subsequent accesses.\n   *\n   * ```js\n   *  class Foo {\n   *    myMappedData = map({\n   *      data: () => [1, 2, 3],\n   *      map: (num) => `hi, ${num}!`\n   *    });\n   *\n   *    get first() {\n   *      return this.myMappedData[0];\n   *    }\n   *  }\n   * ```\n   */\n  [index: number]: MappedTo;\n\n  /**\n   * Evaluate and return an array of all mapped items.\n   *\n   * This is useful when you need to do other Array-like operations\n   * on the mapped data, such as filter, or find.\n   *\n   * ```js\n   *  class Foo {\n   *    myMappedData = map({\n   *      data: () => [1, 2, 3],\n   *      map: (num) => `hi, ${num}!`\n   *    });\n   *\n   *    get everything() {\n   *      return this.myMappedData.values();\n   *    }\n   *  }\n   * ```\n   */\n  values: () => { [K in keyof Elements]: MappedTo };\n\n  /**\n   * Without evaluating the map function on each element,\n   * provide the total number of elements.\n   *\n   * ```js\n   *  class Foo {\n   *    myMappedData = map({\n   *      data: () => [1, 2, 3],\n   *      map: (num) => `hi, ${num}!`\n   *    });\n   *\n   *    get numItems() {\n   *      return this.myMappedData.length;\n   *    }\n   *  }\n   * ```\n   */\n  get length(): number;\n\n  /**\n   * Iterate over the mapped array, lazily invoking the passed map function\n   * that was passed to [[map]].\n   *\n   * This will always return previously mapped records without re-evaluating\n   * the map function, so the default `{{#each}}` behavior in ember will\n   * be optimized on \"object-identity\". e.g.:\n   *\n   * ```js\n   *  // ...\n   *  myMappedData = map({\n   *    data: () => [1, 2, 3],\n   *    map: (num) => `hi, ${num}!`\n   *  });\n   *  // ...\n   * ```\n   * ```hbs\n   *  {{#each this.myMappedData as |datum|}}\n   *     loop body only invoked for changed entries\n   *     {{datum}}\n   *  {{/each}}\n   * ```\n   *\n   * Iteration in javascript is also provided by this iterator\n   * ```js\n   *  class Foo {\n   *    myMappedData = map(this, {\n   *      data: () => [1, 2, 3],\n   *      map: (num) => `hi, ${num}!`\n   *    });\n   *\n   *    get mapAgain() {\n   *      let results = [];\n   *\n   *      for (let datum of this.myMappedData) {\n   *        results.push(datum);\n   *      }\n   *\n   *      return datum;\n   *    }\n   *  }\n   * ```\n   */\n  [Symbol.iterator](): Iterator<MappedTo>;\n}\n\n/**\n * Reactivily apply a `map` function to each element in an array,\n * persisting map-results for each object, based on identity.\n *\n * This is useful when you have a large collection of items that\n * need to be transformed into a different shape (adding/removing/modifying data/properties)\n * and you want the transform to be efficient when iterating over that data.\n *\n * A common use case where this `map` utility provides benefits over is\n * ```js\n * class MyClass {\\\n *   @signal\n *   get wrappedRecords() {\n *     return this.records.map(record => new SomeWrapper(record));\n *   }\n * }\n * ```\n *\n * Even though the above is a cached computed (via `@signal`), if any signal data accessed during the evaluation of `wrappedRecords`\n * changes, the entire array.map will re-run, often doing duplicate work for every unchanged item in the array.\n *\n * @return {MappedArray} an object that behaves like an array. This shouldn't be modified directly. Instead, you can freely modify the data returned by the `data` function, which should be auto-tracked in order to benefit from this abstraction.\n *\n * @example\n *\n * ```js\n *  import { arrayMap } from 'signal-utils/array-map';\n *\n *  class MyClass {\n *    wrappedRecords = map({\n *      data: () => this.records,\n *      map: (record) => new SomeWrapper(record),\n *    }),\n *  }\n * ```\n */\nexport function arrayMap<\n  Elements extends readonly unknown[],\n  MapTo = unknown,\n>(options: {\n  /**\n   * Array of non-primitives to map over\n   *\n   * This can be class instances, plain objects, or anything supported by WeakMap's key\n   */\n  data: () => Elements;\n  /**\n   * Transform each element from `data`, reactively equivalent to `Array.map`.\n   *\n   * This function will be called only when needed / on-demand / lazily.\n   * - if iterating over part of the data, map will only be called for the elements observed\n   * - if not iterating, map will only be called for the elements observed.\n   */\n  map: (element: Elements[0]) => MapTo;\n}): MappedArray<Elements, MapTo> {\n  let { data, map } = options;\n\n  return new TrackedArrayMap(data, map) as MappedArray<Elements, MapTo>;\n}\n\nconst AT = Symbol(\"__AT__\");\n\n/**\n * @private\n */\nexport class TrackedArrayMap<Element = unknown, MappedTo = unknown>\n  implements MappedArray<Element[], MappedTo>\n{\n  // Tells TS that we can array-index-access\n  [index: number]: MappedTo;\n\n  // these can't be real private fields\n  // until @cached is a real decorator\n  private _mapCache = new WeakMap<Element & object, MappedTo>();\n  private _dataFn: () => readonly Element[];\n  private _mapFn: (element: Element) => MappedTo;\n\n  constructor(\n    data: () => readonly Element[],\n    map: (element: Element) => MappedTo,\n  ) {\n    this._dataFn = data;\n    this._mapFn = map;\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n\n    /**\n     * This is what allows square-bracket index-access to work.\n     *\n     * Unfortunately this means the returned value is\n     * Proxy -> Proxy -> wrapper object -> *then* the class instance\n     *\n     * Maybe JS has a way to implement array-index access, but I don't know how\n     */\n    return new Proxy(this, {\n      get(_target, property) {\n        if (typeof property === \"string\") {\n          let parsed = parseInt(property, 10);\n\n          if (!isNaN(parsed)) {\n            return self[AT](parsed);\n          }\n        }\n\n        return self[property as keyof MappedArray<Element[], MappedTo>];\n      },\n      // Is there a way to do this without lying to TypeScript?\n    }) as TrackedArrayMap<Element, MappedTo>;\n  }\n\n  @signal\n  get _records(): (Element & object)[] {\n    let data = this._dataFn();\n\n    if (!data.every((datum) => typeof datum === \"object\")) {\n      throw new Error(\n        `Every entry in the data passed to \\`map\\` must be an object.`,\n      );\n    }\n\n    return data as Array<Element & object>;\n  }\n\n  values = () => [...this];\n\n  get length() {\n    return this._records.length;\n  }\n\n  [Symbol.iterator](): Iterator<MappedTo> {\n    let i = 0;\n\n    return {\n      next: () => {\n        if (i >= this.length) {\n          return { done: true, value: null };\n        }\n\n        let value = this[AT](i);\n\n        i++;\n\n        return {\n          value,\n          done: false,\n        };\n      },\n    };\n  }\n\n  /**\n   * @private\n   *\n   * don't conflict with\n   *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at\n   */\n  [AT] = (i: number) => {\n    let record = this._records[i];\n\n    if (!record) {\n      throw new Error(\n        `Expected record to exist at index ${i}, but it did not. ` +\n          `The array item is expected to exist, because the map utility resource lazily iterates along the indices of the original array passed as data. ` +\n          `This error could happen if the data array passed to map has been mutated while iterating. ` +\n          `To resolve this error, do not mutate arrays while iteration occurs.`,\n      );\n    }\n\n    let value = this._mapCache.get(record);\n\n    if (!value) {\n      value = this._mapFn(record);\n      this._mapCache.set(record, value);\n    }\n\n    return value;\n  };\n}\n"],"names":["arrayMap","options","data","map","TrackedArrayMap","AT","Symbol","_initProto","_applyDecs","signal","e","_mapCache","WeakMap","_dataFn","_mapFn","constructor","self","Proxy","get","_target","property","parsed","parseInt","isNaN","_records","every","datum","Error","values","length","iterator","i","next","done","value","record","set"],"mappings":"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"}