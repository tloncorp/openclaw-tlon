import { Noun } from '@urbit/nockjs';
import { ChannelStatus, Thread, Urbit } from '../http-api';

export type PokeParams = {
    app: string;
    mark: string;
    json: any;
};
export type NounPokeParams = {
    app: string;
    mark: string;
    noun: Noun;
};
export declare class BadResponseError extends Error {
    status: number;
    body: string;
    constructor(status: number, body: string);
}
export declare class TimeoutError extends Error {
    connectionStatus: string;
    timeoutDuration: number | null;
    constructor({ connectionStatus, timeoutDuration, }: {
        connectionStatus?: string;
        timeoutDuration?: number;
    });
}
interface UrbitEndpoint {
    app: string;
    path: string;
}
export interface ClientParams {
    shipName: string;
    shipUrl: string;
    verbose?: boolean;
    fetchFn?: typeof fetch;
    getCode?: () => Promise<string>;
    handleAuthFailure?: () => void;
    onQuitOrReset?: (cause: 'subscriptionQuit' | 'reset') => void;
    onChannelStatusChange?: (status: ChannelStatus) => void;
    /** Inject a pre-configured Urbit client instead of creating one */
    client?: Urbit;
}
export declare const client: Urbit;
export declare const getCurrentUserId: () => string;
export declare const getCurrentUserIsHosted: () => boolean;
export declare function configureClient({ shipName, shipUrl, verbose, fetchFn, getCode, handleAuthFailure, onQuitOrReset, onChannelStatusChange, client: injectedClient, }: ClientParams): Promise<void>;
export declare function internalRemoveClient(): void;
export declare function subscribe<T>(endpoint: UrbitEndpoint, handler: (update: T, id?: number) => void): Promise<number>;
export declare function subscribeOnce<T>(endpoint: UrbitEndpoint, timeout?: number, ship?: string, requestConfig?: {
    tag?: string;
}): Promise<T>;
export declare function unsubscribe(id: number): Promise<void>;
export declare function pokeNoun<T>({ app, mark, noun }: NounPokeParams): Promise<number>;
export declare function poke({ app, mark, json }: PokeParams): Promise<number>;
export declare function trackedPoke<T, R = T>(params: PokeParams, endpoint: UrbitEndpoint, predicate: (event: R) => boolean, requestConfig?: {
    tag?: string;
    timeout?: number;
}): Promise<void>;
export declare function trackedPokeNoun<T, R = T>(params: NounPokeParams, endpoint: UrbitEndpoint, predicate: (event: R) => boolean, requestConfig?: {
    tag: string;
    timeout?: number;
}): Promise<void>;
export declare function checkIsNodeBusy(): Promise<"available" | "busy" | "unknown">;
export declare function checkIsNodeBusyWithHints(): Promise<{
    nodeBusyStatus: 'available' | 'busy' | 'unknown';
    hints?: string;
}>;
export declare function scry<T>({ app, path, timeout, }: {
    app: string;
    path: string;
    timeout?: number;
}): Promise<T>;
export declare function scryNoun({ app, path, timeout, }: {
    app: string;
    path: string;
    timeout?: number;
}): Promise<Noun>;
export declare function thread<T, R = any>(params: Thread<T>): Promise<R>;
export declare function request<T>(path: string, options?: RequestInit, timeout?: number): Promise<T>;
export {};
//# sourceMappingURL=urbit.d.ts.map