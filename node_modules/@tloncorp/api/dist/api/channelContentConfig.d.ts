import { JSONValue } from '../types/JSONValue';
import { ValuesOf } from '../utils';

interface BaseParameterSpec {
    displayName: string;
}
interface BooleanParameterSpec extends BaseParameterSpec {
    type: 'boolean';
}
interface StringParameterSpec extends BaseParameterSpec {
    type: 'string';
}
interface RadioParameterSpec extends BaseParameterSpec {
    type: 'radio';
    options: {
        displayName: string;
        value: string;
    }[];
}
type ParameterSpec = BooleanParameterSpec | StringParameterSpec | RadioParameterSpec;
export interface ComponentSpec<EnumTag extends string = string> {
    displayName: string;
    enumTag: EnumTag;
    parametersSchema?: Record<string, ParameterSpec>;
}
export declare const allCollectionRenderers: {
    readonly 'tlon.r0.collection.chat': {
        readonly displayName: "Chat";
        readonly enumTag: "chat";
        readonly parametersSchema: Record<string, ParameterSpec>;
    };
    readonly 'tlon.r0.collection.gallery': {
        readonly displayName: "Gallery";
        readonly enumTag: "gallery";
        readonly parametersSchema: Record<string, ParameterSpec>;
    };
    readonly 'tlon.r0.collection.notebook': {
        readonly displayName: "Notebook";
        readonly enumTag: "notebook";
        readonly parametersSchema: Record<string, ParameterSpec>;
    };
    readonly 'tlon.r0.collection.carousel': {
        readonly displayName: "Carousel";
        readonly enumTag: "carousel";
        readonly parametersSchema: {
            readonly scrollDirection: {
                readonly displayName: "Scroll direction";
                readonly type: "radio";
                readonly options: readonly [{
                    readonly displayName: "Horizontal";
                    readonly value: "horizontal";
                }, {
                    readonly displayName: "Vertical";
                    readonly value: "vertical";
                }];
            };
        };
    };
    readonly 'tlon.r0.collection.cards': {
        readonly displayName: "Cards";
        readonly enumTag: "cards";
        readonly parametersSchema: Record<string, ParameterSpec>;
    };
    readonly 'tlon.r0.collection.sign': {
        readonly displayName: "Sign";
        readonly enumTag: "sign";
        readonly parametersSchema: Record<string, ParameterSpec>;
    };
    readonly 'tlon.r0.collection.boardroom': {
        readonly displayName: "Boardroom";
        readonly enumTag: "boardroom";
        readonly parametersSchema: Record<string, ParameterSpec>;
    };
    readonly 'tlon.r0.collection.strobe': {
        readonly displayName: "Strobe";
        readonly enumTag: "strobe";
        readonly parametersSchema: {
            readonly interval: {
                readonly displayName: "Frame rate in milliseconds";
                readonly type: "string";
            };
        };
    };
    readonly 'tlon.r0.collection.summaries': {
        readonly displayName: "Summaries";
        readonly enumTag: "summaries";
        readonly parametersSchema: Record<string, ParameterSpec>;
    };
};
export declare const allDraftInputs: {
    readonly 'tlon.r0.input.chat': {
        readonly displayName: "Chat";
        readonly enumTag: "chat";
    };
    readonly 'tlon.r0.input.gallery': {
        readonly displayName: "Gallery";
        readonly enumTag: "gallery";
    };
    readonly 'tlon.r0.input.notebook': {
        readonly displayName: "Notebook";
        readonly enumTag: "notebook";
    };
    readonly 'tlon.r0.input.yo': {
        readonly displayName: "Yo";
        readonly enumTag: "yo";
        readonly parametersSchema: {
            readonly text: {
                readonly displayName: "Message text";
                readonly type: "string";
            };
        };
    };
    readonly 'tlon.r0.input.mic': {
        readonly displayName: "Mic";
        readonly enumTag: "mic";
    };
    readonly 'tlon.r0.input.color': {
        readonly displayName: "Color";
        readonly enumTag: "color";
    };
};
export declare const allContentRenderers: {
    readonly 'tlon.r0.content.chat': {
        readonly displayName: "Chat";
        readonly enumTag: "chat";
    };
    readonly 'tlon.r0.content.gallery': {
        readonly displayName: "Gallery";
        readonly enumTag: "gallery";
        readonly parametersSchema: {
            readonly embedded: {
                readonly displayName: "Show frame";
                readonly type: "boolean";
            };
            readonly contentSize: {
                readonly displayName: "Content size";
                readonly type: "radio";
                readonly options: readonly [{
                    readonly displayName: "Large";
                    readonly value: "$l";
                }, {
                    readonly displayName: "Small";
                    readonly value: "$s";
                }];
            };
        };
    };
    readonly 'tlon.r0.content.notebook': {
        readonly displayName: "Notebook";
        readonly enumTag: "notebook";
    };
    readonly 'tlon.r0.content.audio': {
        readonly displayName: "Audio";
        readonly enumTag: "audio";
    };
    readonly 'tlon.r0.content.color': {
        readonly displayName: "Color";
        readonly enumTag: "color";
    };
    readonly 'tlon.r0.content.raw': {
        readonly displayName: "Raw";
        readonly enumTag: "raw";
        readonly parametersSchema: {
            readonly fontFamily: {
                readonly displayName: "Font family";
                readonly type: "string";
            };
        };
    };
    readonly 'tlon.r0.content.yell': {
        readonly displayName: "Yell";
        readonly enumTag: "yell";
    };
    readonly 'tlon.r0.content.scratchpad': {
        readonly displayName: "Scratchpad";
        readonly enumTag: "scratchpad";
    };
};
export declare const CollectionRendererId: {
    [x: string]: string;
};
export type CollectionRendererId = ValuesOf<typeof CollectionRendererId>;
export declare const DraftInputId: {
    readonly chat: "tlon.r0.input.chat";
    readonly gallery: "tlon.r0.input.gallery";
    readonly notebook: "tlon.r0.input.notebook";
    readonly yo: "tlon.r0.input.yo";
    readonly mic: "tlon.r0.input.mic";
    readonly color: "tlon.r0.input.color";
};
export type DraftInputId = ValuesOf<typeof DraftInputId>;
export declare const PostContentRendererId: {
    [x: string]: string;
};
export type PostContentRendererId = ValuesOf<typeof PostContentRendererId>;
type ParameterizedId<Id extends string> = {
    id: Id;
    configuration?: Record<string, JSONValue>;
};
declare namespace ParameterizedId {
    function id<Id extends string>(id: ParameterizedId<Id>): Id;
    function coerce<Id extends string>(id: Id | ParameterizedId<Id>): ParameterizedId<Id>;
}
/**
 * Configures the custom components used to create content in a channel.
 */
export interface ChannelContentConfiguration {
    /**
     * Which controls are available when composing a new post?
     */
    draftInput: DraftInputId | ParameterizedId<DraftInputId>;
    /**
     * How should we render a given post content type?
     *
     * This spec takes precedence over the client's default renderer mapping, but
     * does not take precedence over any mapping specified in a post's metadata.
     */
    defaultPostContentRenderer: PostContentRendererId | ParameterizedId<PostContentRendererId>;
    /**
     * How should we render the entire collection of posts? (list, grid, etc)
     */
    defaultPostCollectionRenderer: CollectionRendererId | ParameterizedId<CollectionRendererId>;
}
export declare namespace ChannelContentConfiguration {
    function defaultConfiguration(): ChannelContentConfiguration;
    function draftInput(configuration: ChannelContentConfiguration): ParameterizedId<DraftInputId>;
    function defaultPostContentRenderer(configuration: ChannelContentConfiguration): ParameterizedId<PostContentRendererId>;
    function defaultPostCollectionRenderer(configuration: ChannelContentConfiguration): ParameterizedId<CollectionRendererId>;
}
/**
 * We use a channel's `description` field to store structured data. This
 * module provides helpers for managing that data.
 */
export declare namespace StructuredChannelDescriptionPayload {
    type Encoded = string | null | undefined;
    interface Decoded {
        channelContentConfiguration?: ChannelContentConfiguration;
        description?: string;
    }
    export function encode(payload: Decoded): Encoded;
    /**
     * Attempts to decode a `description` string into a structured payload.
     *
     * - If `description` is null/undefined, returns a payload with no
     *   description nor configuration.
     * - If `description` is not valid JSON, returns a payload with the
     *   description as the input string.
     * - If `description` validates as the expected
     *   `StructuredChannelDescriptionPayload` JSON, returns the decoded payload.
     */
    export function decode(encoded: Encoded): Decoded;
    export {};
}
export {};
//# sourceMappingURL=channelContentConfig.d.ts.map