#!/usr/bin/env python3
"""
Tlon CLI - Interact with Tlon/Urbit via HTTP API.

Usage:
    tlon contacts self|get|list|update [options]
    tlon channels list|groups|dms|info [options]
    tlon history --target <nest|ship> [--limit N]
    tlon react add|remove --channel <nest> --post-id <id> [--emoji <emoji>]
    tlon post edit|delete --channel <nest> --post-id <id> [--content <text>]
    tlon dm accept|decline|send|reply [options]
    tlon notebook add --channel <nest> --title <title> --content <markdown>
    tlon activity unread|mentions|all [--limit N]

Configuration via environment variables:
    TLON_URL   - Ship URL (e.g., https://your-ship.tlon.network)
    TLON_SHIP  - Ship name (e.g., ~zod)
    TLON_CODE  - Access code
"""

from __future__ import annotations

import argparse
import json
import os
import re
import sys
import time
import urllib.error
import urllib.parse
import urllib.request
from http.cookiejar import CookieJar
from typing import Any, Dict, List, Optional, Tuple, Union

# =============================================================================
# Urbit Time Conversion (@da format)
# =============================================================================

DA_UNIX_EPOCH = 170141184475152167957503069145530368000  # ~1970.1.1
DA_SECOND = 18446744073709551616  # 2^64 = ~s1


def from_unix_ms(unix_ms: int) -> int:
    """Convert Unix milliseconds to Urbit @da."""
    return DA_UNIX_EPOCH + (unix_ms * DA_SECOND // 1000)


def format_ud(n: int) -> str:
    """Format integer as @ud with dots every 3 digits."""
    s = str(n)
    parts: List[str] = []
    while s:
        parts.insert(0, s[-3:] if len(s) >= 3 else s)
        s = s[:-3] if len(s) >= 3 else ""
    return ".".join(parts)


def make_post_id(ship: str, unix_ms: int) -> str:
    """Generate a post ID from ship and timestamp."""
    da_value = from_unix_ms(unix_ms)
    return f"{ship}/{format_ud(da_value)}"


def normalize_post_id(post_id: str) -> str:
    """Extract just the @ud part from a post ID (after the /)."""
    if "/" in post_id:
        return post_id.split("/", 1)[1]
    return post_id


# =============================================================================
# Markdown to Story Conversion
# =============================================================================

StoryInline = Union[str, Dict[str, Any]]
StoryVerse = Dict[str, Any]
Story = List[StoryVerse]


def parse_inline_markdown(text: str) -> List[StoryInline]:
    """Parse inline markdown formatting."""
    result: List[StoryInline] = []
    remaining = text

    while remaining:
        # Ship mentions: ~sampel-palnet
        match = re.match(r"^(~[a-z][-a-z0-9]*)", remaining)
        if match:
            result.append({"ship": match.group(1)})
            remaining = remaining[len(match.group(0)) :]
            continue

        # Bold: **text** or __text__
        match = re.match(r"^\*\*(.+?)\*\*|^__(.+?)__", remaining)
        if match:
            content = match.group(1) or match.group(2)
            result.append({"bold": parse_inline_markdown(content)})
            remaining = remaining[len(match.group(0)) :]
            continue

        # Italics: *text* or _text_
        match = re.match(r"^\*([^*]+?)\*|^_([^_]+?)_(?![a-zA-Z0-9])", remaining)
        if match:
            content = match.group(1) or match.group(2)
            result.append({"italics": parse_inline_markdown(content)})
            remaining = remaining[len(match.group(0)) :]
            continue

        # Strikethrough: ~~text~~
        match = re.match(r"^~~(.+?)~~", remaining)
        if match:
            result.append({"strike": parse_inline_markdown(match.group(1))})
            remaining = remaining[len(match.group(0)) :]
            continue

        # Inline code: `code`
        match = re.match(r"^`([^`]+)`", remaining)
        if match:
            result.append({"inline-code": match.group(1)})
            remaining = remaining[len(match.group(0)) :]
            continue

        # Links: [text](url)
        match = re.match(r"^\[([^\]]+)\]\(([^)]+)\)", remaining)
        if match:
            result.append({"link": {"href": match.group(2), "content": match.group(1)}})
            remaining = remaining[len(match.group(0)) :]
            continue

        # Plain URL detection
        match = re.match(r"^(https?://[^\s<>\"'\]]+)", remaining)
        if match:
            result.append({"link": {"href": match.group(1), "content": match.group(1)}})
            remaining = remaining[len(match.group(0)) :]
            continue

        # Plain text: consume until next special character
        match = re.match(r"^[^*_`~\[\n]+", remaining)
        if match:
            result.append(match.group(0))
            remaining = remaining[len(match.group(0)) :]
            continue

        # Single special char that didn't match a pattern
        result.append(remaining[0])
        remaining = remaining[1:]

    # Merge adjacent strings
    merged: List[StoryInline] = []
    for item in result:
        if isinstance(item, str) and merged and isinstance(merged[-1], str):
            merged[-1] = merged[-1] + item
        else:
            merged.append(item)

    return merged


def markdown_to_story(markdown: str) -> Story:
    """Convert markdown text to Tlon story format."""
    story: Story = []
    lines = markdown.split("\n")
    i = 0

    while i < len(lines):
        line = lines[i]

        # Code block: ```lang\ncode\n```
        if line.startswith("```"):
            lang = line[3:].strip() or "plaintext"
            code_lines: List[str] = []
            i += 1
            while i < len(lines) and not lines[i].startswith("```"):
                code_lines.append(lines[i])
                i += 1
            story.append({"block": {"code": {"code": "\n".join(code_lines), "lang": lang}}})
            i += 1  # skip closing ```
            continue

        # Headers: # H1, ## H2, etc.
        match = re.match(r"^(#{1,6})\s+(.+)$", line)
        if match:
            level = len(match.group(1))
            tag = f"h{level}"
            story.append({"block": {"header": {"tag": tag, "content": parse_inline_markdown(match.group(2))}}})
            i += 1
            continue

        # Horizontal rule: --- or ***
        if re.match(r"^(-{3,}|\*{3,})$", line.strip()):
            story.append({"block": {"rule": None}})
            i += 1
            continue

        # Blockquote: > text
        if line.startswith("> "):
            quote_lines: List[str] = []
            while i < len(lines) and lines[i].startswith("> "):
                quote_lines.append(lines[i][2:])
                i += 1
            quote_text = "\n".join(quote_lines)
            story.append({"inline": [{"blockquote": parse_inline_markdown(quote_text)}]})
            continue

        # Empty line - skip
        if not line.strip():
            i += 1
            continue

        # Regular paragraph
        para_lines: List[str] = []
        while (
            i < len(lines)
            and lines[i].strip()
            and not lines[i].startswith("#")
            and not lines[i].startswith("```")
            and not lines[i].startswith("> ")
            and not re.match(r"^(-{3,}|\*{3,})$", lines[i].strip())
        ):
            para_lines.append(lines[i])
            i += 1

        if para_lines:
            para_text = "\n".join(para_lines)
            inlines = parse_inline_markdown(para_text)
            # Replace \n with break elements
            with_breaks: List[StoryInline] = []
            for inline in inlines:
                if isinstance(inline, str) and "\n" in inline:
                    parts = inline.split("\n")
                    for j, part in enumerate(parts):
                        if part:
                            with_breaks.append(part)
                        if j < len(parts) - 1:
                            with_breaks.append({"break": None})
                else:
                    with_breaks.append(inline)
            if with_breaks:
                story.append({"inline": with_breaks})

    return story


# =============================================================================
# Urbit HTTP Client
# =============================================================================


class UrbitClient:
    """Lightweight Urbit HTTP client for scry and poke operations."""

    def __init__(self, url: str, ship: str, code: str):
        self.url = url.rstrip("/")
        self.ship = ship if ship.startswith("~") else f"~{ship}"
        self.code = code
        self.cookie_jar = CookieJar()
        self.opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(self.cookie_jar))
        self._logged_in = False

    def _login(self) -> None:
        """Authenticate with the ship."""
        if self._logged_in:
            return

        login_url = f"{self.url}/~/login"
        data = urllib.parse.urlencode({"password": self.code}).encode("utf-8")
        req = urllib.request.Request(login_url, data=data, method="POST")
        req.add_header("Content-Type", "application/x-www-form-urlencoded")

        try:
            with self.opener.open(req) as resp:
                if resp.status != 200 and resp.status != 204:
                    raise RuntimeError(f"Login failed with status {resp.status}")
        except urllib.error.HTTPError as e:
            raise RuntimeError(f"Login failed: {e.code} {e.reason}")

        self._logged_in = True

    def scry(self, app: str, path: str) -> Any:
        """Perform a scry (read) operation."""
        self._login()

        # Ensure path starts with /
        if not path.startswith("/"):
            path = "/" + path

        scry_url = f"{self.url}/~/scry/{app}{path}.json"
        req = urllib.request.Request(scry_url, method="GET")

        try:
            with self.opener.open(req) as resp:
                return json.loads(resp.read().decode("utf-8"))
        except urllib.error.HTTPError as e:
            if e.code == 404:
                return None
            raise RuntimeError(f"Scry failed: {e.code} {e.reason}")

    def poke(self, app: str, mark: str, data: Any) -> None:
        """Perform a poke (write) operation."""
        self._login()

        # Create ephemeral channel
        channel_id = f"tlon-cli-{int(time.time() * 1000)}"
        channel_url = f"{self.url}/~/channel/{channel_id}"

        # Build poke request
        poke_id = 1
        payload = [
            {
                "id": poke_id,
                "action": "poke",
                "ship": self.ship.lstrip("~"),
                "app": app,
                "mark": mark,
                "json": data,
            }
        ]

        req = urllib.request.Request(
            channel_url,
            data=json.dumps(payload).encode("utf-8"),
            method="PUT",
        )
        req.add_header("Content-Type", "application/json")

        try:
            with self.opener.open(req) as resp:
                if resp.status not in (200, 204):
                    raise RuntimeError(f"Poke failed with status {resp.status}")
        except urllib.error.HTTPError as e:
            raise RuntimeError(f"Poke failed: {e.code} {e.reason}")

        # Clean up channel
        delete_payload = [{"id": poke_id + 1, "action": "delete"}]
        req = urllib.request.Request(
            channel_url,
            data=json.dumps(delete_payload).encode("utf-8"),
            method="PUT",
        )
        req.add_header("Content-Type", "application/json")
        try:
            with self.opener.open(req):
                pass
        except Exception:
            pass  # Ignore cleanup errors


# =============================================================================
# Command Handlers
# =============================================================================


def cmd_contacts(client: UrbitClient, args: argparse.Namespace) -> Dict[str, Any]:
    """Handle contacts subcommand."""
    action = args.action

    if action == "self":
        result = client.scry("contacts", "/v1/self")
        return result or {}

    elif action == "get":
        if not args.ship:
            raise ValueError("--ship required for 'get' action")
        ship = args.ship if args.ship.startswith("~") else f"~{args.ship}"
        result = client.scry("contacts", f"/v1/contact/{ship}")
        return result or {}

    elif action == "list":
        result = client.scry("contacts", "/v1/all")
        if not result:
            return []
        return [{"ship": ship, **profile} for ship, profile in result.items()]

    elif action == "update":
        edit_fields: List[Dict[str, str]] = []
        if args.nickname:
            edit_fields.append({"nickname": args.nickname})
        if args.bio:
            edit_fields.append({"bio": args.bio})
        if args.status:
            edit_fields.append({"status": args.status})
        if args.avatar:
            edit_fields.append({"avatar": args.avatar})
        if args.cover:
            edit_fields.append({"cover": args.cover})

        if not edit_fields:
            raise ValueError("At least one profile field required for 'update'")

        client.poke("contacts", "contact-action", {"edit": edit_fields})
        return {"updated": len(edit_fields)}

    else:
        raise ValueError(f"Unknown contacts action: {action}")


def cmd_channels(client: UrbitClient, args: argparse.Namespace) -> Dict[str, Any]:
    """Handle channels subcommand."""
    action = args.action

    if action == "list":
        result = client.scry("channels", "/v2/channels")
        if not result:
            return []
        # Return channel nests as list
        return list(result.keys())

    elif action == "groups":
        result = client.scry("groups", "/groups")
        if not result:
            return []
        return list(result.keys())

    elif action == "dms":
        result = client.scry("chat", "/dm")
        return result if result else []

    elif action == "info":
        if not args.channel:
            raise ValueError("--channel required for 'info' action")
        # URL-encode the channel path
        encoded = urllib.parse.quote(args.channel, safe="")
        result = client.scry("channels", f"/v2/channels/{encoded}")
        return result or {}

    else:
        raise ValueError(f"Unknown channels action: {action}")


def cmd_history(client: UrbitClient, args: argparse.Namespace) -> Dict[str, Any]:
    """Handle history subcommand."""
    target = args.target
    limit = args.limit or 20

    # Determine if target is a DM (starts with ~) or channel
    if target.startswith("~"):
        # DM history
        ship = target
        result = client.scry("chat", f"/v3/dm/{ship}/writs/newest/{limit}/light")
        if not result or "writs" not in result:
            return []
        # Transform writs to list
        writs = result["writs"]
        messages = []
        for writ_id, writ in writs.items():
            messages.append({
                "id": writ_id,
                "author": writ.get("essay", {}).get("author"),
                "sent": writ.get("essay", {}).get("sent"),
                "content": writ.get("essay", {}).get("content"),
            })
        return messages
    else:
        # Channel history
        encoded = urllib.parse.quote(target, safe="")
        result = client.scry("channels", f"/v4/{encoded}/posts/newest/{limit}/outline")
        if not result or "posts" not in result:
            return []
        posts = result["posts"]
        messages = []
        for post_id, post in posts.items():
            messages.append({
                "id": post_id,
                "author": post.get("essay", {}).get("author"),
                "sent": post.get("essay", {}).get("sent"),
                "content": post.get("essay", {}).get("content"),
                "replyCount": post.get("seal", {}).get("meta", {}).get("replyCount", 0),
            })
        return messages


def cmd_react(client: UrbitClient, args: argparse.Namespace) -> Dict[str, Any]:
    """Handle react subcommand."""
    action = args.action
    channel = args.channel
    post_id = args.post_id

    if not channel or not post_id:
        raise ValueError("--channel and --post-id required")

    formatted_id = normalize_post_id(post_id)

    # Check if DM reaction
    if channel.startswith("dm/"):
        ship = channel[3:]  # Remove "dm/" prefix
        if action == "add":
            if not args.emoji:
                raise ValueError("--emoji required for 'add' action")
            delta = {"add-react": {"react": args.emoji, "author": client.ship}}
        else:
            delta = {"del-react": {"author": client.ship}}

        client.poke("chat", "chat-dm-action-1", {
            "ship": ship,
            "diff": {"id": formatted_id, "delta": delta},
        })
    else:
        # Channel reaction
        if action == "add":
            if not args.emoji:
                raise ValueError("--emoji required for 'add' action")
            post_action = {"add-react": {"id": formatted_id, "react": args.emoji, "ship": client.ship}}
        else:
            post_action = {"del-react": {"id": formatted_id, "ship": client.ship}}

        client.poke("channels", "channel-action-1", {
            "channel": {"nest": channel, "action": {"post": post_action}},
        })

    return {"success": True, "action": action}


def cmd_post(client: UrbitClient, args: argparse.Namespace) -> Dict[str, Any]:
    """Handle post subcommand."""
    action = args.action
    channel = args.channel
    post_id = args.post_id

    if not channel or not post_id:
        raise ValueError("--channel and --post-id required")

    formatted_id = normalize_post_id(post_id)

    if action == "delete":
        client.poke("channels", "channel-action-1", {
            "channel": {"nest": channel, "action": {"post": {"del": formatted_id}}},
        })
        return {"deleted": post_id}

    elif action == "edit":
        if not args.content:
            raise ValueError("--content required for 'edit' action")

        # Determine kind based on channel type
        if channel.startswith("diary/"):
            kind = "/diary"
        elif channel.startswith("heap/"):
            kind = "/heap"
        else:
            kind = "/chat"

        content = markdown_to_story(args.content)
        sent = int(time.time() * 1000)

        essay: Dict[str, Any] = {
            "content": content,
            "author": client.ship,
            "sent": sent,
            "kind": kind,
            "blob": None,
        }

        if kind == "/diary":
            essay["meta"] = {
                "title": args.title or "",
                "description": "",
                "image": "",
                "cover": "",
            }
        else:
            essay["meta"] = None

        client.poke("channels", "channel-action-1", {
            "channel": {"nest": channel, "action": {"post": {"edit": {"id": formatted_id, "essay": essay}}}},
        })
        return {"edited": post_id}

    else:
        raise ValueError(f"Unknown post action: {action}")


def cmd_dm(client: UrbitClient, args: argparse.Namespace) -> Dict[str, Any]:
    """Handle dm subcommand."""
    action = args.action

    if action == "accept":
        if not args.ship:
            raise ValueError("--ship required for 'accept' action")
        ship = args.ship if args.ship.startswith("~") else f"~{args.ship}"
        client.poke("chat", "chat-dm-rsvp", {"ship": ship, "ok": True})
        return {"accepted": ship}

    elif action == "decline":
        if not args.ship:
            raise ValueError("--ship required for 'decline' action")
        ship = args.ship if args.ship.startswith("~") else f"~{args.ship}"
        client.poke("chat", "chat-dm-rsvp", {"ship": ship, "ok": False})
        return {"declined": ship}

    elif action == "send":
        if not args.club_id or not args.message:
            raise ValueError("--club-id and --message required for 'send' action")

        sent = int(time.time() * 1000)
        content = markdown_to_story(args.message)
        post_id = make_post_id(client.ship, sent)

        client.poke("chat", "chat-club-action-0", {
            "id": args.club_id,
            "diff": {
                "uid": post_id,
                "delta": {
                    "add": {
                        "memo": {
                            "content": content,
                            "author": client.ship,
                            "sent": sent,
                        }
                    }
                },
            },
        })
        return {"sent": post_id}

    elif action == "reply":
        if not args.club_id or not args.post_id or not args.message:
            raise ValueError("--club-id, --post-id, and --message required for 'reply' action")

        sent = int(time.time() * 1000)
        content = markdown_to_story(args.message)
        reply_id = make_post_id(client.ship, sent)

        client.poke("chat", "chat-club-action-0", {
            "id": args.club_id,
            "diff": {
                "uid": args.post_id,
                "delta": {
                    "reply": {
                        "id": reply_id,
                        "meta": None,
                        "delta": {
                            "add": {
                                "memo": {
                                    "content": content,
                                    "author": client.ship,
                                    "sent": sent,
                                }
                            }
                        },
                    }
                },
            },
        })
        return {"replied": reply_id}

    else:
        raise ValueError(f"Unknown dm action: {action}")


def cmd_notebook(client: UrbitClient, args: argparse.Namespace) -> Dict[str, Any]:
    """Handle notebook subcommand."""
    if not args.channel or not args.title or not args.content:
        raise ValueError("--channel, --title, and --content required")

    sent = int(time.time() * 1000)
    content = markdown_to_story(args.content)

    essay = {
        "content": content,
        "author": client.ship,
        "sent": sent,
        "kind": "/diary",
        "blob": None,
        "meta": {
            "title": args.title,
            "description": "",
            "image": args.image or "",
            "cover": args.image or "",
        },
    }

    client.poke("channels", "channel-action-1", {
        "channel": {"nest": args.channel, "action": {"post": {"add": essay}}},
    })

    return {"created": make_post_id(client.ship, sent)}


def cmd_activity(client: UrbitClient, args: argparse.Namespace) -> Dict[str, Any]:
    """Handle activity subcommand."""
    action = args.action
    limit = args.limit or 20

    if action == "unread":
        result = client.scry("activity", "/v4/activity/unreads")
        return result or {}

    elif action in ("mentions", "all"):
        result = client.scry("activity", f"/v5/feed/init/{limit}")
        if not result:
            return {}
        if action == "mentions":
            return result.get("mentions", [])
        return result

    else:
        raise ValueError(f"Unknown activity action: {action}")


def generate_group_slug() -> str:
    """Generate a random short ID for group/channel slugs."""
    import random
    import string
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))


def cmd_groups(client: UrbitClient, args: argparse.Namespace) -> Dict[str, Any]:
    """Handle groups subcommand."""
    action = args.action

    if action == "list":
        result = client.scry("groups", "/v2/groups")
        if not result:
            return []
        groups = []
        for group_id, group in result.items():
            groups.append({
                "id": group_id,
                "title": group.get("meta", {}).get("title", ""),
                "privacy": group.get("admissions", {}).get("privacy", "unknown"),
                "members": len(group.get("seats", {})),
                "channels": len(group.get("channels", {})),
            })
        return groups

    elif action == "info":
        if not args.group:
            raise ValueError("--group required for 'info' action")
        result = client.scry("groups", f"/v2/ui/groups/{args.group}")
        if not result:
            return {}
        return {
            "id": args.group,
            "title": result.get("meta", {}).get("title", ""),
            "description": result.get("meta", {}).get("description", ""),
            "privacy": result.get("admissions", {}).get("privacy", "unknown"),
            "members": list(result.get("seats", {}).keys()),
            "channels": list(result.get("channels", {}).keys()),
            "roles": list(result.get("roles", {}).keys()),
            "banned": result.get("admissions", {}).get("banned", {}).get("ships", []),
            "requests": list(result.get("admissions", {}).get("requests", {}).keys()),
            "invited": list(result.get("admissions", {}).get("invited", {}).keys()),
        }

    elif action == "join":
        if not args.group:
            raise ValueError("--group required for 'join' action")
        client.poke("groups", "group-join", {"flag": args.group, "join-all": True})
        return {"joined": args.group}

    elif action == "leave":
        if not args.group:
            raise ValueError("--group required for 'leave' action")
        client.poke("groups", "group-leave", args.group)
        return {"left": args.group}

    elif action == "delete":
        if not args.group:
            raise ValueError("--group required for 'delete' action")
        client.poke("groups", "group-action-4", {
            "group": {"flag": args.group, "a-group": {"delete": None}}
        })
        return {"deleted": args.group}

    elif action == "invite":
        if not args.group or not args.ships:
            raise ValueError("--group and --ships required for 'invite' action")
        ships = [s if s.startswith("~") else f"~{s}" for s in args.ships]
        client.poke("groups", "group-action-4", {
            "invite": {"flag": args.group, "ships": ships, "a-invite": {"token": None, "note": None}}
        })
        return {"invited": ships, "group": args.group}

    elif action == "kick":
        if not args.group or not args.ships:
            raise ValueError("--group and --ships required for 'kick' action")
        ships = [s if s.startswith("~") else f"~{s}" for s in args.ships]
        client.poke("groups", "group-action-4", {
            "group": {"flag": args.group, "a-group": {"seat": {"ships": ships, "a-seat": {"del": None}}}}
        })
        return {"kicked": ships, "group": args.group}

    elif action == "ban":
        if not args.group or not args.ships:
            raise ValueError("--group and --ships required for 'ban' action")
        ships = [s if s.startswith("~") else f"~{s}" for s in args.ships]
        client.poke("groups", "group-action-4", {
            "group": {"flag": args.group, "a-group": {"entry": {"ban": {"add-ships": ships}}}}
        })
        return {"banned": ships, "group": args.group}

    elif action == "unban":
        if not args.group or not args.ships:
            raise ValueError("--group and --ships required for 'unban' action")
        ships = [s if s.startswith("~") else f"~{s}" for s in args.ships]
        client.poke("groups", "group-action-4", {
            "group": {"flag": args.group, "a-group": {"entry": {"ban": {"del-ships": ships}}}}
        })
        return {"unbanned": ships, "group": args.group}

    elif action == "set-privacy":
        if not args.group or not args.privacy:
            raise ValueError("--group and --privacy required for 'set-privacy' action")
        if args.privacy not in ("public", "private", "secret"):
            raise ValueError("--privacy must be public, private, or secret")
        client.poke("groups", "group-action-4", {
            "group": {"flag": args.group, "a-group": {"entry": {"privacy": args.privacy}}}
        })
        return {"group": args.group, "privacy": args.privacy}

    elif action == "accept-join":
        if not args.group or not args.ships:
            raise ValueError("--group and --ships required for 'accept-join' action")
        ships = [s if s.startswith("~") else f"~{s}" for s in args.ships]
        client.poke("groups", "group-action-4", {
            "group": {"flag": args.group, "a-group": {"entry": {"ask": {"ships": ships, "a-ask": "approve"}}}}
        })
        return {"accepted": ships, "group": args.group}

    elif action == "reject-join":
        if not args.group or not args.ships:
            raise ValueError("--group and --ships required for 'reject-join' action")
        ships = [s if s.startswith("~") else f"~{s}" for s in args.ships]
        client.poke("groups", "group-action-4", {
            "group": {"flag": args.group, "a-group": {"entry": {"ask": {"ships": ships, "a-ask": "deny"}}}}
        })
        return {"rejected": ships, "group": args.group}

    elif action == "add-role":
        if not args.group or not args.role:
            raise ValueError("--group and --role required for 'add-role' action")
        title = args.title or args.role
        description = args.description or ""
        client.poke("groups", "group-action-4", {
            "group": {"flag": args.group, "a-group": {"role": {"roles": [args.role], "a-role": {
                "add": {"title": title, "description": description, "image": "", "cover": ""}
            }}}}
        })
        return {"role": args.role, "group": args.group}

    elif action == "delete-role":
        if not args.group or not args.role:
            raise ValueError("--group and --role required for 'delete-role' action")
        client.poke("groups", "group-action-4", {
            "group": {"flag": args.group, "a-group": {"role": {"roles": [args.role], "a-role": {"del": None}}}}
        })
        return {"deleted_role": args.role, "group": args.group}

    elif action == "assign-role":
        if not args.group or not args.role or not args.ships:
            raise ValueError("--group, --role and --ships required for 'assign-role' action")
        ships = [s if s.startswith("~") else f"~{s}" for s in args.ships]
        client.poke("groups", "group-action-4", {
            "group": {"flag": args.group, "a-group": {"seat": {"ships": ships, "a-seat": {"add-roles": [args.role]}}}}
        })
        return {"role": args.role, "assigned_to": ships, "group": args.group}

    elif action == "remove-role":
        if not args.group or not args.role or not args.ships:
            raise ValueError("--group, --role and --ships required for 'remove-role' action")
        ships = [s if s.startswith("~") else f"~{s}" for s in args.ships]
        client.poke("groups", "group-action-4", {
            "group": {"flag": args.group, "a-group": {"seat": {"ships": ships, "a-seat": {"del-roles": [args.role]}}}}
        })
        return {"role": args.role, "removed_from": ships, "group": args.group}

    else:
        raise ValueError(f"Unknown groups action: {action}")


SETTINGS_DESK = "moltbot"
SETTINGS_BUCKET = "tlon"


def cmd_settings(client: UrbitClient, args: argparse.Namespace) -> Dict[str, Any]:
    """Handle settings subcommand."""
    action = args.action

    if action == "get":
        try:
            result = client.scry("settings", "/all")
            settings = result.get("all", {}).get(SETTINGS_DESK, {}).get(SETTINGS_BUCKET, {})
            return settings
        except Exception:
            return {}

    elif action == "set":
        if not args.key or args.value is None:
            raise ValueError("--key and --value required for 'set' action")
        try:
            value = json.loads(args.value)
        except json.JSONDecodeError:
            value = args.value
        client.poke("settings", "settings-event", {
            "put-entry": {
                "desk": SETTINGS_DESK,
                "bucket-key": SETTINGS_BUCKET,
                "entry-key": args.key,
                "value": value,
            }
        })
        return {"set": args.key, "value": value}

    elif action == "delete":
        if not args.key:
            raise ValueError("--key required for 'delete' action")
        client.poke("settings", "settings-event", {
            "del-entry": {
                "desk": SETTINGS_DESK,
                "bucket-key": SETTINGS_BUCKET,
                "entry-key": args.key,
            }
        })
        return {"deleted": args.key}

    elif action == "allow-dm":
        if not args.ship:
            raise ValueError("--ship required for 'allow-dm' action")
        ship = args.ship if args.ship.startswith("~") else f"~{args.ship}"
        try:
            result = client.scry("settings", "/all")
            settings = result.get("all", {}).get(SETTINGS_DESK, {}).get(SETTINGS_BUCKET, {})
            current = settings.get("dmAllowlist", [])
        except Exception:
            current = []
        if ship not in current:
            current.append(ship)
            client.poke("settings", "settings-event", {
                "put-entry": {
                    "desk": SETTINGS_DESK,
                    "bucket-key": SETTINGS_BUCKET,
                    "entry-key": "dmAllowlist",
                    "value": current,
                }
            })
        return {"dmAllowlist": current}

    elif action == "remove-dm":
        if not args.ship:
            raise ValueError("--ship required for 'remove-dm' action")
        ship = args.ship if args.ship.startswith("~") else f"~{args.ship}"
        try:
            result = client.scry("settings", "/all")
            settings = result.get("all", {}).get(SETTINGS_DESK, {}).get(SETTINGS_BUCKET, {})
            current = settings.get("dmAllowlist", [])
        except Exception:
            current = []
        if ship in current:
            current.remove(ship)
            client.poke("settings", "settings-event", {
                "put-entry": {
                    "desk": SETTINGS_DESK,
                    "bucket-key": SETTINGS_BUCKET,
                    "entry-key": "dmAllowlist",
                    "value": current,
                }
            })
        return {"dmAllowlist": current}

    elif action == "allow-channel":
        if not args.channel:
            raise ValueError("--channel required for 'allow-channel' action")
        try:
            result = client.scry("settings", "/all")
            settings = result.get("all", {}).get(SETTINGS_DESK, {}).get(SETTINGS_BUCKET, {})
            current = settings.get("groupChannels", [])
        except Exception:
            current = []
        if args.channel not in current:
            current.append(args.channel)
            client.poke("settings", "settings-event", {
                "put-entry": {
                    "desk": SETTINGS_DESK,
                    "bucket-key": SETTINGS_BUCKET,
                    "entry-key": "groupChannels",
                    "value": current,
                }
            })
        return {"groupChannels": current}

    elif action == "remove-channel":
        if not args.channel:
            raise ValueError("--channel required for 'remove-channel' action")
        try:
            result = client.scry("settings", "/all")
            settings = result.get("all", {}).get(SETTINGS_DESK, {}).get(SETTINGS_BUCKET, {})
            current = settings.get("groupChannels", [])
        except Exception:
            current = []
        if args.channel in current:
            current.remove(args.channel)
            client.poke("settings", "settings-event", {
                "put-entry": {
                    "desk": SETTINGS_DESK,
                    "bucket-key": SETTINGS_BUCKET,
                    "entry-key": "groupChannels",
                    "value": current,
                }
            })
        return {"groupChannels": current}

    elif action == "open-channel":
        if not args.channel:
            raise ValueError("--channel required for 'open-channel' action")
        try:
            result = client.scry("settings", "/all")
            settings = result.get("all", {}).get(SETTINGS_DESK, {}).get(SETTINGS_BUCKET, {})
            rules_str = settings.get("channelRules", "{}")
            rules = json.loads(rules_str) if isinstance(rules_str, str) else rules_str
        except Exception:
            rules = {}
        rules[args.channel] = {"mode": "open"}
        client.poke("settings", "settings-event", {
            "put-entry": {
                "desk": SETTINGS_DESK,
                "bucket-key": SETTINGS_BUCKET,
                "entry-key": "channelRules",
                "value": json.dumps(rules),
            }
        })
        return {"channel": args.channel, "mode": "open"}

    elif action == "restrict-channel":
        if not args.channel:
            raise ValueError("--channel required for 'restrict-channel' action")
        try:
            result = client.scry("settings", "/all")
            settings = result.get("all", {}).get(SETTINGS_DESK, {}).get(SETTINGS_BUCKET, {})
            rules_str = settings.get("channelRules", "{}")
            rules = json.loads(rules_str) if isinstance(rules_str, str) else rules_str
        except Exception:
            rules = {}
        rule: Dict[str, Any] = {"mode": "restricted"}
        if args.ships:
            rule["allowedShips"] = [s if s.startswith("~") else f"~{s}" for s in args.ships]
        rules[args.channel] = rule
        client.poke("settings", "settings-event", {
            "put-entry": {
                "desk": SETTINGS_DESK,
                "bucket-key": SETTINGS_BUCKET,
                "entry-key": "channelRules",
                "value": json.dumps(rules),
            }
        })
        return {"channel": args.channel, "mode": "restricted", "allowedShips": rule.get("allowedShips", [])}

    else:
        raise ValueError(f"Unknown settings action: {action}")


# =============================================================================
# Main CLI
# =============================================================================


def get_config() -> Tuple[str, str, str]:
    """Get configuration from environment variables."""
    url = os.environ.get("TLON_URL")
    ship = os.environ.get("TLON_SHIP")
    code = os.environ.get("TLON_CODE")

    missing = []
    if not url:
        missing.append("TLON_URL")
    if not ship:
        missing.append("TLON_SHIP")
    if not code:
        missing.append("TLON_CODE")

    if missing:
        raise RuntimeError(f"Missing environment variables: {', '.join(missing)}")

    return url, ship, code


def output_result(success: bool, data: Any = None, error: str = None) -> None:
    """Output result as JSON."""
    if success:
        print(json.dumps({"success": True, "data": data}))
    else:
        print(json.dumps({"success": False, "error": error}))


def main() -> int:
    parser = argparse.ArgumentParser(description="Tlon CLI - Interact with Tlon/Urbit")
    subparsers = parser.add_subparsers(dest="command", required=True)

    # contacts
    p_contacts = subparsers.add_parser("contacts", help="Manage contacts and profiles")
    p_contacts.add_argument("action", choices=["self", "get", "list", "update"])
    p_contacts.add_argument("--ship", help="Ship for 'get' action")
    p_contacts.add_argument("--nickname", help="Nickname for 'update' action")
    p_contacts.add_argument("--bio", help="Bio for 'update' action")
    p_contacts.add_argument("--status", help="Status for 'update' action")
    p_contacts.add_argument("--avatar", help="Avatar URL for 'update' action")
    p_contacts.add_argument("--cover", help="Cover URL for 'update' action")

    # channels
    p_channels = subparsers.add_parser("channels", help="List channels and groups")
    p_channels.add_argument("action", choices=["list", "groups", "dms", "info"])
    p_channels.add_argument("--channel", help="Channel nest for 'info' action")

    # history
    p_history = subparsers.add_parser("history", help="Fetch message history")
    p_history.add_argument("--target", required=True, help="Channel nest or ~ship for DM")
    p_history.add_argument("--limit", type=int, default=20, help="Number of messages")

    # react
    p_react = subparsers.add_parser("react", help="Add/remove reactions")
    p_react.add_argument("action", choices=["add", "remove"])
    p_react.add_argument("--channel", required=True, help="Channel nest or dm/~ship")
    p_react.add_argument("--post-id", required=True, help="Post ID")
    p_react.add_argument("--emoji", help="Emoji for 'add' action")

    # post
    p_post = subparsers.add_parser("post", help="Edit/delete posts")
    p_post.add_argument("action", choices=["edit", "delete"])
    p_post.add_argument("--channel", required=True, help="Channel nest")
    p_post.add_argument("--post-id", required=True, help="Post ID")
    p_post.add_argument("--content", help="New content for 'edit' action")
    p_post.add_argument("--title", help="Title for diary posts")

    # dm
    p_dm = subparsers.add_parser("dm", help="Manage DMs")
    p_dm.add_argument("action", choices=["accept", "decline", "send", "reply"])
    p_dm.add_argument("--ship", help="Ship for accept/decline")
    p_dm.add_argument("--club-id", help="Club ID for send/reply")
    p_dm.add_argument("--post-id", help="Post ID for reply")
    p_dm.add_argument("--message", help="Message content")

    # notebook
    p_notebook = subparsers.add_parser("notebook", help="Create notebook posts")
    p_notebook.add_argument("action", choices=["add"], default="add", nargs="?")
    p_notebook.add_argument("--channel", required=True, help="Diary channel nest")
    p_notebook.add_argument("--title", required=True, help="Post title")
    p_notebook.add_argument("--content", required=True, help="Markdown content")
    p_notebook.add_argument("--image", help="Cover image URL")

    # activity
    p_activity = subparsers.add_parser("activity", help="Check activity")
    p_activity.add_argument("action", choices=["unread", "mentions", "all"])
    p_activity.add_argument("--limit", type=int, default=20, help="Limit for mentions/all")

    # groups
    p_groups = subparsers.add_parser("groups", help="Manage groups")
    p_groups.add_argument("action", choices=[
        "list", "info", "join", "leave", "delete",
        "invite", "kick", "ban", "unban",
        "set-privacy", "accept-join", "reject-join",
        "add-role", "delete-role", "assign-role", "remove-role"
    ])
    p_groups.add_argument("--group", help="Group ID (e.g., ~host/slug)")
    p_groups.add_argument("--ships", nargs="+", help="Ship names")
    p_groups.add_argument("--role", help="Role ID")
    p_groups.add_argument("--title", help="Title for roles")
    p_groups.add_argument("--description", help="Description")
    p_groups.add_argument("--privacy", choices=["public", "private", "secret"])

    # settings
    p_settings = subparsers.add_parser("settings", help="Manage bot settings")
    p_settings.add_argument("action", choices=[
        "get", "set", "delete",
        "allow-dm", "remove-dm",
        "allow-channel", "remove-channel",
        "open-channel", "restrict-channel"
    ])
    p_settings.add_argument("--key", help="Setting key")
    p_settings.add_argument("--value", help="Setting value (JSON)")
    p_settings.add_argument("--ship", help="Ship name")
    p_settings.add_argument("--channel", help="Channel nest")
    p_settings.add_argument("--ships", nargs="+", help="Ship names for restrict-channel")

    args = parser.parse_args()

    try:
        url, ship, code = get_config()
        client = UrbitClient(url, ship, code)

        if args.command == "contacts":
            result = cmd_contacts(client, args)
        elif args.command == "channels":
            result = cmd_channels(client, args)
        elif args.command == "history":
            result = cmd_history(client, args)
        elif args.command == "react":
            result = cmd_react(client, args)
        elif args.command == "post":
            result = cmd_post(client, args)
        elif args.command == "dm":
            result = cmd_dm(client, args)
        elif args.command == "notebook":
            result = cmd_notebook(client, args)
        elif args.command == "activity":
            result = cmd_activity(client, args)
        elif args.command == "groups":
            result = cmd_groups(client, args)
        elif args.command == "settings":
            result = cmd_settings(client, args)
        else:
            raise ValueError(f"Unknown command: {args.command}")

        output_result(True, data=result)
        return 0

    except Exception as e:
        output_result(False, error=str(e))
        return 1


if __name__ == "__main__":
    sys.exit(main())
